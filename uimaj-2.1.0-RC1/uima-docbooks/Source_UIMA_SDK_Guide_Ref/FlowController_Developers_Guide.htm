<document>
  <properties>
    <title>Flow Controller Developer's Guide</title>
  </properties>
<body>



<div class="chapter">
<div class="Section1">



<section name="Flow Controller Developer's Guide"><a id="_crossRef213"> </a>



<p>A Flow Controller is a component that plugs into an
Aggregate Analysis Engine.  When a CAS is
input to the Aggregate, the Flow Controller determines the order in which the
components of that aggregate are invoked on that CAS.  The ability to provide your own Flow
Controller implementation is new as of release 2.0 of UIMA.  </p>

<p>Flow Controllers may decide the flow dynamically, based on
the contents of the CAS.  So, as just one
example, you could develop a Flow Controller that first sends each CAS to a
Language Identification Annotator and then, based on the output of the Language
Identification Annotator, routes that CAS to an Annotator that is specialized
for that particular language.  </p>



<subsection name="Developing the Flow Controller Code"><a id="_crossRef214"> </a>



<h3><a id="_crossRef215">Flow Controller Interface Overview</a></h3>

<p>Flow Controller implementations should extend from the <code>JCasFlowController_ImplBase</code> or <code>CasFlowController_ImplBase</code>
classes, depending on which CAS interface they prefer to use.  As with other types of components, the Flow
Controller ImplBase classes define optional <code>initialize</code>,
<code>destroy</code>, and <code>reconfigure</code>
methods.  They also define the required
method <code>computeFlow</code>.  </p>

<p>The <code>computeFlow</code> method is
called by the framework whenever a new CAS enters the Aggregate Analysis
Engine.  It is given the CAS as an
argument and must return an object which implements the <code>Flow</code>
interface (the Flow object).  The Flow
Controller developer must define this object.  It is the object that is responsible for routing this particular CAS
through the components of the Aggregate Analysis Engine.  For convenience, the framework provides basic
implementation of flow objects in the classes  CasFlow_ImplBase and JCasFlow_ImplBase; use the JCas one if you are
using the JCas interface to the CAS.</p>

<p>The framework then uses the Flow object and calls its <code>next()</code> method, which returns a <code>Step</code>
object (implemented by the UIMA Framework) that indicates what to do next with
this CAS next.  There are two common
types of steps:</p>

<ul><li><code>SimpleStep</code>,
which indicates the Analysis Engine that should receive the CAS next.</li>


<li><code>FinalStep</code>,
which indicates that the flow is completed.
</li></ul>

<p>There may be additional types of steps added in future
versions; for example to invoke multiple Analysis Engines in parallel on the
same CAS.</p>

<p>After executing the step, the framework will call the Flow
object's <code>next()</code> method again to determine the next
destination, and this will be repeated until the Flow Object indicates that
processing is complete by returning a <code>FinalStep</code>.</p>

<p>The Flow Controller has access to a <code>FlowControllerContext</code>,
which is a subtype of <code>UimaContext</code>.  In addition to the configuration parameter
and resource access provided by a <code>UimaContext</code>, the <code>FlowControllerContext</code> also gives access to the metadata
for all of the Analysis Engines that the Flow Controller can route CASes
to.  Most Flow Controllers will need to
use this information to make routing decisions.  You can get a handle to the <code>FlowControllerContext</code>
by calling the <code>getContext()</code> method defined in <code>JCasFlowController_ImplBase</code> and <code>CasFlowController_ImplBase</code>.  Then, the <code>FlowControllerContext.
getAnalysisEngineMetaDataMap</code> can be called to get a map containing an
entry for each of the Analysis Engines in the Aggregate.  The keys in this map are the same as the
delegate analysis engine keys specified in the aggregate descriptor, and the
values are the corresponding Analysis Engine MetaData objects.  </p>

<h3><a id="_crossRef216">Example Code</a></h3>

<p>This section walks through the source code of an example
Flow Controller that implements a simple version of the &quot;Whiteboard&quot;
flow model.  At each step of the flow,
the Flow Controller looks it all of the available Analysis Engines that have
not yet run on this CAS, and picks one whose input requirements are satisfied.</p>

<p>The Java class for the example is <code>com.ibm.uima.examples.flow.WhiteboardFlowController</code>
and the source code is included in the UIMA SDK under the <code>docs/examples/src</code>
directory.</p>

<h4>The
WhiteboardFlowController Class</h4>

<p class="xmp">public class WhiteboardFlowController extends CasFlowController_ImplBase
{
  public Flow computeFlow(CAS aCAS) throws AnalysisEngineProcessException
  {
    WhiteboardFlow flow = new WhiteboardFlow();
    flow.setCas(aCAS);
    return flow;
  }<br/> <br/> </p>

<p class="xmp">  class WhiteboardFlow extends CasFlow_ImplBase
  {
     // Discussed Later
  }
}</p>

<p>The <code>WhiteboardFlowController</code>
extends from <code>CasFlowController_ImplBase</code> and
implements the <code>computeFlow</code> method.  The implementation of the <code>computeFlow</code> method is very simple; it just constructs a
new <code>WhiteboardFlow</code> object that will be responsible
for routing this CAS, and calls the <code>WhiteboardFlow.setCas</code>
method to give it a handle to that CAS, which it will later use to make its
routing decisions.  The <code>setCas</code> method is a method provided by the <code>..._ImplBase</code> classes for Flows.</p>

<p>Note that we will have one instance of <code>WhiteboardFlow</code> per CAS, so if there are multiple CASes
being simultaneously processed there will not be any confusion. </p>

<h4>The WhiteboardFlow
Class</h4>

<p class="xmp">  class WhiteboardFlow extends CasFlow_ImplBase
  {
    private Set mAlreadyCalled = new HashSet();

    public Step next() throws AnalysisEngineProcessException
    {
      //Get the CAS that this Flow object is responsible for routing.
      //Each Flow instance is responsible for a single CAS
      CAS cas = getCas();
      
      //iterate over available AEs
      Iterator aeIter = getContext().getAnalysisEngineMetaDataMap()
                        .entrySet().iterator();
      while (aeIter.hasNext())
      {
        Map.Entry entry = (Map.Entry) aeIter.next();
        //skip AEs that were already called on this CAS
        String aeKey = (String) entry.getKey();
        if (!mAlreadyCalled.contains(aeKey))
        {
          //check for satisfied input capabilities 
          // (i.e. the CAS contains at least one instance
          //of each required input)
          AnalysisEngineMetaData md = 
            (AnalysisEngineMetaData)entry.getValue();
          Capability[] caps = md.getCapabilities();
          boolean satisfied = true;
          for (int i = 0; i &lt; caps.length; i++)
          {
            satisfied = inputsSatisfied(caps[i].getInputs(), cas);
            if (satisfied)
              break;
          }
          if (satisfied)
          {
            mAlreadyCalled.add(aeKey);
            return new SimpleStep(aeKey);
          }
        }
      }</p>

<p class="xmp">      //no appropriate AEs to call - end of flow
      return new FinalStep();
    }</p>

<p class="xmp"></p>

<p class="xmp">    private boolean inputsSatisfied(TypeOrFeature[] aInputs, CAS aCAS)</p>

<p class="xmp">    {
      //implementation detail; see the actual source code
    }
  }</p>

<p>Each instance of the <code>WhiteboardFlowController</code>
is responsible for routing a single CAS.  A handle to the CAS instance is available by calling the <code>getCas()</code> method, which is a standard method defined on
the <code>CasFlow_ImplBase </code>superclass.</p>

<p>Each time the <code>next</code> method is
called, the Flow object iterates over the metadata of all of the available
Analysis Engines (obtained via the call to <code>getContext().
getAnalysisEngineMetaDataMap)</code> and sees if the input types declared in an
AnalysisEngineMetaData object are satisfied by the CAS (that is, the CAS
contains at least one instance of each declared input type).  The exact details of checking for instances
of types in the CAS are not discussed here &ndash; see the
WhiteboardFlowController.java file for the complete source.</p>

<p>When the Flow object decides which AnalysisEngine should
be called next, it indicates this by creating a SimpleStep object with the key
for that AnalysisEngine and returning it:</p>

<p class="xmp">return new SimpleStep(aeKey);</p>

<p>The Flow object keeps a list of which Analysis Engines it
has invoked in the <code>mAlreadyCalled</code> field, and never
invokes the same Analysis Engine twice.  Note this is not a hard requirement.  It is acceptable to design a FlowController
that invokes the same Analysis Engine more than once; however, if you do this
you must make sure that the flow will eventually terminate.</p>

<p>If there are no Analysis Engines left whose input
requirements are satisfied, the Flow object signals the end of the flow by
returning a FinalStep object:</p>

<p class="xmp">return new FinalStep();</p>




  </subsection>
<subsection name="Creating the Flow Controller Descriptor"><a id="_crossRef217"> </a>



<p>To create a Flow Controller Descriptor in the CDE, use
File -&gt; New -&gt; Other -&gt; UIMA -&gt; Flow Controller Descriptor File:</p>

<p><img alt="" width="503" height="405"
src="../UIMA_SDK_Guide_Ref/FlowController_Developers_Guide_files/image002.jpg"/></p>

<p>This will bring up the Overview page for the Flow
Controller Descriptor:</p>

<p><img alt="" width="467" height="383"
src="../UIMA_SDK_Guide_Ref/FlowController_Developers_Guide_files/image004.jpg"/></p>

<p>Type in the Java class name that implements the Flow
Controller, or use the &quot;Browse&quot; button to select it.  You must select a Java class that implements
the <code>FlowController</code> interface.</p>

<p>Flow Controller Descriptors are very similar to Primitive
Analysis Engine Descriptors &ndash; for example you can specify configuration
parameters and external resources if you wish.</p>

<p>If you wish to edit a Flow Controller Descriptor by hand,
see section <b><a class="crossrefText" href="Component_Descriptor_Reference.htm#_crossRef145">Flow
Controller Descriptors</a></b> <a class="crossrefPage" href="Component_Descriptor_Reference.htm#_crossRef145"></a> for the syntax.</p>




  </subsection>
<subsection name="Adding a Flow Controller to an Aggregate Analysis Engine"><a id="_crossRef218"> </a>



<p>To use a Flow Controller you must add it to an Aggregate
Analysis Engine.  You can only have one
Flow Controller per Aggregate Analysis Engine.  In the Component Descriptor Editor, the Flow Controller is specified on
the Aggregate page, as a choice in the flow control kind - pick User-defined
Flow.  When you do, the Browse and Search
buttons underneath become active, and allow you to specify an existing Flow
Controller Descriptor, which when you select it, will be imported into the
aggregate descriptor.  </p>

<p><img alt="" width="409" height="213"
src="../UIMA_SDK_Guide_Ref/FlowController_Developers_Guide_files/image006.jpg"/></p>

<p>The key name is created automatically from the name
element in the Flow Controller Descriptor being imported. If you need to change
this name, you can do so by switching to the &quot;Source&quot; view using the
bottom tabs, and editing the name in the XML source.</p>

<p>If you edit your Aggregate Analysis Engine Descriptor by
hand, the syntax for adding a Flow Controller is:</p>

<p class="xmp">  &lt;delegateAnalysisEngineSpecifiers&gt;
    ...
  &lt;/delegateAnalysisEngineSpecifiers&gt;</p>

<p class="xmp">  <b>&lt;flowController key=&quot;[String]&quot;&gt;
    &lt;import .../&gt; 
  &lt;/flowController&gt;</b></p>

<p>As usual, you can use either in import by location or
import by name &ndash; see <b><a class="crossrefText" href="Component_Descriptor_Reference.htm#_crossRef122">Imports</a></b> <a class="crossrefPage" href="Component_Descriptor_Reference.htm#_crossRef122"></a>.</p>

<p>The key that you assign to the FlowController can be used
elsewhere in the Aggregate Analysis Engine Descriptor &ndash; in parameter overrides,
resource bindings, and Sofa mappings.</p>




  </subsection>
<subsection name="Adding a Flow Controller to a Collection Processing Engine"><a id="_crossRef219"> </a>



<p>Flow Controllers cannot be added directly to Collection
Processing Engines.  To use a Flow
Controller in a CPE you first need to wrap the part of your CPE that requires
complex flow control into an Aggregate Analysis Engine, and then add the
Aggregate Analysis Engine to your CPE.  The CPE's deployment and error handling options can then only be
configured for the entire Aggregate Analysis Engine as a unit.</p>




  </subsection>
<subsection name="Using Flow Controllers with CAS Multipliers"><a id="_crossRef220"> </a>



<p>If you want your Flow Controller to work inside an
Aggregate Analysis Engine that contains a CAS Multiplier (see <b><a class="crossrefText" href="Segmenter_Developers_Guide.htm#_crossRef273">CAS Multiplier
Developer's Guide</a></b> <a class="crossrefPage" href="Segmenter_Developers_Guide.htm#_crossRef273"></a>), there are additional things you must consider.</p>

<p>When your Flow Controller routes a CAS to a CAS
Multiplier, the CAS Multiplier may produce new CASes that then will also need
to be routed by the Flow Controller.  When a new output CAS is produced, the framework will call the method:</p>

<p class="xmp">protected Flow newCasProduced(AbstractCas newOutputCas, String producedBy)  </p>

<p>on the Flow object that was managing the flow of the
parent CAS (the one that was input to the CAS Multiplier).  The <code>newCasProduced</code>
method must create a new Flow object that will be responsible for routing the
new output CAS.</p>

<p>In the <code>CasFlow_ImplBase</code> and <code>JCasFlow_ImplBase</code> classes, the <code>newCasProduced</code>
method is defined to throw an exception indicating that the Flow Controller
does not handle CAS Multipliers.  If you
want your Flow Controller to properly deal with CAS Multipliers you must
override this method.</p>

<p>Also, there is a variant of <code>FinalStep</code>
which can only be specified for output CASes produced by CAS Multipliers within
the Aggregate Analysis Engine containing the Flow Controller.  This version of <code>FinalStep</code>
is produced by the calling the constructor with a <code>true</code>
argument, and it causes the CAS to be immediately released back to the
pool.  No further processing will be done
on it and it will not be output from the aggregate.  This is the way that you can build an
Aggregate Analysis Engine that outputs some new CASes but not others.  Note that if you never want any new CASes to
be output from the Aggregate Analysis Engine, you don't need to use this;
instead just declare <code>&lt;outputsNewCASes&gt;false&lt;/outputsNewCASes&gt;</code>
in your Aggregate Analysis Engine Descriptor as described in section <b><a class="crossrefText" href="Segmenter_Developers_Guide.htm#_crossRef282">Aggregate </a></b> <a class="crossrefPage" href="Segmenter_Developers_Guide.htm#_crossRef282"></a>.</p>

</div>
<div class="footnotesHere"></div>
</div>



  </subsection>

</section>
</body>
</document>
