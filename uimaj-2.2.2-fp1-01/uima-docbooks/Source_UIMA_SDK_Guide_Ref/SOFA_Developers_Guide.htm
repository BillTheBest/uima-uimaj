<document>
  <properties>
    <title>Annotations, Artifacts, and Sofas</title>
  </properties>
<body>



<div class="chapter">
<div class="Section1">



<section name="Annotations, Artifacts, and Sofas"><a id="_crossRef286"> </a>



<p>Up to this point, the documentation has focused on
analyzing strings of Unicode text, producing subtypes of Annotations which
reference offsets in those strings.  This
chapter generalizes this concept and shows how other kinds of artifacts can be
handled, including non-text things like audio and images, and how you can
define your own kinds of &quot;annotations&quot; for these.</p>



<subsection name="Terminology"><a id="_crossRef287"> </a>



<h3><a id="_crossRef288">Artifact</a></h3>

<p>The Artifact is the unstructured thing being analyzed by
an annotator.  It could be an HTML web
page, an image, a video stream, a recorded audio conversation, an MPEG-4
stream, etc.  Artifacts are often
restructured in the course of processing to facilitate particular kinds of
analysis.  For instance, an HTML page may
be convered into a &quot;de-tagged&quot; version.  Annotators at different places in the
pipeline may be analyzing different versions of the artifact.</p>

<h3><a id="_crossRef289">Subject of Analysis -- Sofa</a></h3>

<p>Each representation of an Artifact is called a Subject of
Analysis, abbreviated using the acronym &quot;Sofa&quot; which stands for <u>S</u>ubject
<u>OF</u> <u>A</u>nalysis. Annotation metadata, which have explicit
designations of sub-regions of the artifact to which they apply, are always
associated with a particular Sofa.  For
instance, an annotation over text specifies two features, the begin and end,
which represent the character offsets into the text string Sofa being
analyzed.  </p>

<p>Other examples of representations of Artifacts, which
could be Sofas include:  An HTML web
page, a detagged web page, the translated text of that document, an audio or
video stream,  closed-caption text from a
video stream, etc.</p>

<p>Often, there is one Sofa being analyzed in a CAS.  The next chapter will show how UIMA
facilitates working with multiple representations of an artifact at the same
time, in the same CAS.  </p>




  </subsection>
<subsection name="Formats of Sofa Data"><a id="_crossRef290"> </a>



<p>Sofa data can be Java Unicode Strings, Feature Structure
arrays of primitive types, or a URI which references remote data available via
a network connection.</p>

<p>The arrays of primitive types can be things like byte
arrays or float arrays, and are intended to be used for artifacts like audio
data, image data, etc.</p>

<p>The URI form holds a URI specification String.</p>




  </subsection>
<subsection name="Setting and Accessing Sofa Data"><a id="_crossRef291"> </a>



<h3><a id="_crossRef292">Setting Sofa Data</a></h3>

<p>When a CAS is created, you can set its Sofa Data, just one
time; this property insures that metadata describing regions of the Sofa remain
valid.  As a consequence, the following
methods that set data for a given Sofa can only be called once for a given
Sofa.</p>

<p>The following methods on the CAS set the Sofa Data to one
of the 3 formats.  Assume that the
variable &quot;aCas&quot; holds a reference to a CAS:</p>

<p class="xmp">aCas.<b>setSofaDataString</b>(document_text_string, mime_type_string);
aCas.<b>setSofaDataArray</b>(feature_structure_primitive_array, mime_type_string);
aCas.<b>setSofaDataURI</b>(uri_string, mime_type_string);</p>

<p>In addition, the method <code>aCas.setDocumentText(document_text_string)</code>
may still be used, and is equivalent to <code>setSofaDataString(string,
&quot;text&quot;)</code>. The mime type is currently not used by the UIMA
framework, but may be set and retrieved by user code.</p>

<p>Feature Structure primitive arrays are all the UIMA Array
types except arrays of Feature Structures, Strings, and Booleans.  Typically, these are arrays of bytes, but can
be other types, such as floats, longs, etc.</p>

<p>The URI string should conform to the standard URI format.</p>

<h3><a id="_crossRef293">Accessing Sofa Data</a></h3>

<p>The analysis algorithms typically work with the Sofa
data.  The following methods on the CAS
access the Sofa Data:</p>

<p class="xmp">String           aCas.getDocumentText();
String           aCas.getSofaDataString();
FeatureStructure aCas.getSofaDataArray();
String           aCas.getSofaDataURI();
String           aCas.getSofaMimeType();</p>

<p>The <code>getDocumentText</code> and <code>getSofaDataString</code> return the same text string.  The <code>getSofaDataURI</code>
returns the URI itself, not the data the URI is pointing to. You can use
standard Java I/O capabilities to get the data associated with the URI, or use
the UIMA Framework Streaming method described next. </p>

<h3><a id="_crossRef294">Accessing Sofa Data using a Java
Stream</a></h3>

<p>The framework provides a consistent method for accessing
the Sofa data, independent of it being stored locally, or accessed remotely
using the URI. Get a Java InputStream instance from the Sofa data using:</p>

<p class="xmp">InputStream inputStream = aCas.getSofaDataStream();</p>

<ul class="compact"><li>If the data is local, this method
returns a ByteArrayInputStream.  This
stream provides bytes.


<ul><li>If the Sofa data was set using
setDocumentText or setSofaDataString, the String is converted to bytes by using
the UTF-8 encoding.  </li>


<li>If the Sofa data was set as a
DataArray, the bytes in the data array are serialized, high-byte first.
</li></ul></li>


<li>If the Sofa data was specified as
a URI, this method returns the handle from url.openStream().  Java offers built-in support for several URI
schemes including &ldquo;FILE:&quot;, &quot;HTTP:&quot;, &quot;FTP:&quot;and has an
extensible mechanism, <code>URLStreamHandlerFactory</code>,
for customizing access to an arbitrary URI. See more details at <code><a
href="http://java.sun.com/j2se/1.4.2/docs/api/java/net/URLStreamHandlerFactory.html">http://java.sun.com/j2se/1.4.2/docs/api/java/net/URLStreamHandlerFactory.html</a>.</code>
</li></ul>




  </subsection>
<subsection name="The Sofa Feature Structure"><a id="_crossRef295"> </a>



<p>Information about a Sofa is contained in a special
built-in Feature Structure of type <code>uima.cas.Sofa</code>.  This feature structure is created and managed
by the UIMA Framework; users must not create it directly.  Although these Sofa type instances are
implemented as standard feature structures, <i>generic CAS APIs can not be used
to create Sofas or set their features</i>. Instead, Sofas are created
implicitly by the creation of new CAS views. Similarly, Sofa features are set
by CAS methods such as <code>cas.setDocumentText()</code>.</p>

<p>Features of the Sofa type include</p>

<ul><li>SofaID:  Every Sofa in a CAS has a unique SofaID.
SofaIDs are the primary handle for access.  This ID is often the same as the name string given to the Sofa by the
developer, but it can be mapped to a different name (see <b><a class="crossrefText" href="SOFA_Developers_Guide.htm#_crossRef309">Sofa Name Mapping</a></b> <a class="crossrefPage" href="SOFA_Developers_Guide.htm#_crossRef309"></a>).</li>


<li>Mime type: This string feature can
be used to describe the type of the data represented by a Sofa.  It is not used by the framework; the
framework provides APIs to set and get its value.</li>


<li>Sofa Data:  The Sofa data itself. This data can be
resident in the CAS or it can be a reference to data outside the CAS.
</li></ul>




  </subsection>
<subsection name="Annotations"><a id="_crossRef296"> </a>



<p>Annotators add meta data about a Sofa to the CAS.  It is often useful to have this metadata
denote a region of the Sofa to which it applies.  For instance, assuming the Sofa is a String,
the metadata might describe a particular substring as the name of a
person.  The built-in UIMA type,
uima.tcas.Annotation, has two extra features that enable this - the begin and
end features - which denote a character position offset into the text string
being analyzed.</p>

<p>The concept of &quot;annotations&quot; can be generalized
for non-string kinds of Sofas.  For
instance, an audio stream might have an audio annotation which describes sounds
regions in terms of floating point time offsets in the Sofa.  An image annotation might use two pairs of
x,y coordinates to define the region the annotation applies to.</p>

<h3><a id="_crossRef297">Built-in Annotation types</a></h3>

<p>The built-in CAS type, <code>uima.tcas.Annotation</code>,
is just one kind of definition of an Annotation.  It was designed for annotating text strings,
and has begin and end features which describe which substring of the Sofa being
annotated.  </p>

<p>For applications which have other kinds of Sofas, the UIMA
developer will design their own kinds of Annotation types, as needed to
describe an annotation, by declaring new types which are subtypes of <code>uima.cas.AnnotationBase</code>.  For instance, for images, you might have the concept of a rectangular
region to which the annotation applies.  In this case, you might describe the region with 2 pairs of x, y
coordinates.</p>

<h3><a id="_crossRef298">Annotations have an associated
Sofa</a></h3>

<p>Annotations are always associated with a particular
Sofa.  In subsequent chapters, you will
learn how there can be multiple Sofas associated with an artifact; which Sofa
an annotation refers to is described by the Annotation feature structure
itself.</p>

<p>All annotation types extend from the built-in type
uima.cas.AnnotationBase.  This type has
one feature, a reference to the Sofa associated with the annotation.  This value is currently used by the Framework
to support the getCoveredText() method on the annotation instance - this
returns the portion of a text Sofa that the annotation spans.   It also is used to insure that the
Annotation is indexed only in the CAS View associated with this Sofa.</p>




  </subsection>
<subsection name="AnnotationBase"><a id="_crossRef299"> </a>



<p>A built-in type, <code>uima.cas.AnnotationBase</code>,
is provided by UIMA to allow users to extend the Annotation capabilities to
different kinds of Annotations.  The <code>AnnotationBase</code> type has one feature, the <code>SofaRef</code>, which holds a pointer to the <code>SofaFS</code> feature structure, another built-in type that is
used to represent a Sofa in the framework. The <code>SofaFS</code>
feature is automatically set when creating an annotation (any type derived from
the built-in <code>uima.cas.AnnotationBase </code>type); it
should not be set by the user.</p>

<p>There is one method, <code>getView</code>(),
provided by <code>AnnotationBase that returns</code> the CAS
View for the Sofa the annotation is pointing at.  Note that this method always returns a CAS,
even when applied to JCas annotation instances.</p>

<p>The built-in type <code>uima.tcas.Annotation</code>
extends <code>uima.cas.AnnotationBase</code> and adds two
features, a begin and an end feature, which are suitable for identifying a span
in a text string that the annotation applies to.  Users may define other extensions to <code>AnnotationBase</code> with alternative specifications that can
denote a particular region within the subject of analysis, as appropriate to
their application.</p>

</div>

<br/>


<div class="Section2">




  </subsection>

</section>
<section name="Multiple CAS Views of an Artifact"><a id="_crossRef300"> </a>



<p>UIMA provides an extension to the basic model of the CAS
which supports analysis of multiple views of the same artifact, all contained
with the CAS.  This chapter describes the
concepts, terminology, and the API and XML extensions that enable this.  </p>

<p>Multiple CAS Views can simplify things when different
versions of the artifact are needed at different stages of the analysis.   They are also key to enabling multimodal
analysis where the initial artifact is transformed from one modality to
another, or where the artifact itself is multimodal, such as the audio, video
and closed-captioned text associated with an MPEG object.  Each representation of the artifact can be
analyzed independently with the standard UIMA programming model; in addition,
multi-view components and applications can be constructed.</p>

<p>UIMA supports this by augmenting the CAS with additional light-weight
CAS objects, one for each view, where these objects share most of the same
underlying CAS, except for two things:  each view has its own set of indexed Feature Structures, and each view
has its own subject of analysis (Sofa) - its own version of the artifact being
analyzed.  The Feature Structure
instances themselves are in the shared part of the CAS; only the entries in the
indexes are unique for each CAS view.   </p>

<p>All of these CAS view objects are kept together with the
CAS, and passed as a unit between components in a UIMA application.  APIs exist which allow components and
applications to switch among the various view objects, as needed.</p>

<p>Feature Structures may be indexed in multiple views, if
necessary.  New methods on CAS Views
facilitate adding or removing Feature Structures to or from their index
repositories:</p>

<p class="xmp"><code>aView.addFsToIndexes(aFeatureStructure)</code> <code>aView.removeFsFromIndexes(aFeatureStructure)</code> </p>

<p>specify the view in which this Feature Structure should be
added to or removed from the indexes. </p>



<subsection name="CAS Views and Sofas"><a id="_crossRef301"> </a>



<p>Sofas (see <b><a class="crossrefText" href="SOFA_Developers_Guide.htm#_crossRef289">Subject
of Analysis -- Sofa</a></b> <a class="crossrefPage" href="SOFA_Developers_Guide.htm#_crossRef289"></a>) and CAS Views are linked.  In this implementation, every CAS view has
one associated Sofa, and every Sofa has one associated CAS View.</p>

<h3><a id="_crossRef302">Naming CAS Views and Sofas</a></h3>

<p>The developer assigns a name to the View / Sofa, which is
a simple string (following the rules for Java identifiers, usually without
periods, but see special exception below).  These names are declared in the component XML metadata, and are used
during assembly and by the runtime to enable switching among multiple Views of
the CAS at the same time.</p>

<ul class="note"><li>The name is called the Sofa name, for historical reasons, but it applies
equally to the View.  In the rest of this
chapter, we'll refer to it as the Sofa name.
</li></ul>

<p>Some applications contain components that expect a
variable number of Sofas as input or output.  An example of a component that takes a variable number of input Sofas
could be one that takes several translations of a document and merges them,
where each translation was in a separate Sofa.  You can specify a variable number of input or output sofa names, where
each name has the same base part, by writing the base part of the name (with no
periods), followed by a period character and an asterisk character (.*).   These denote sofas that have names matching
the base part up to the period; for example, names such as <code>base_name_part.TTX_3d</code> would match a specification of <code>base_name_part.*</code>.</p>

<h3><a id="_crossRef303">Multi-View and Single-View
components and applications</a></h3>

<p>Components and applications can be written to be
Multi-View or Single-View.  Most
components used as primitive building blocks are expected to be
Single-View.  UIMA provides capabilities
to combine these kinds of components with Multi-View components when assembling
analysis aggregates or applications.</p>

<p>Single-View components and applications use only one
subject of analysis, and one CAS View.   The code and descriptors for these components do not use the facilities
described in this chapter.</p>

<p>Conversely, Multi-View components and applications are
aware of the possibility of multiple Views and Sofas, and have code and XML
descriptors that create and manipulate them.</p>




  </subsection>
<subsection name="Multi-View Components"><a id="_crossRef304"> </a>



<h3><a id="_crossRef305">How UIMA decides if a component is
Multi-View</a></h3>

<p>Every UIMA component has an associated XML Component
Descriptor.  Multi-View components are
identified simply as those whose descriptors declare one or more Sofa names in
their Capability sections, as inputs or outputs.  If a Component Descriptor does not mention
any input or output Sofa names, the framework treats that component as a
Single-View component.</p>

<p>A Multi-View component is passed a special kind of a CAS
object, called a base CAS, which it must use to switch to the particular view
it wishes to process.  The base CAS
object itself has no Sofa and no ability to use Indexes; only the views have
that capability.</p>

<h3><a id="_crossRef306">Multi-View: additional
capabilities</a></h3>

<p>Additional capabilities provided for components and
applications aware of the possibilities of multiple Views and Sofas include:</p>

<ul class="compact"><li>Creating new Views, and for each,
setting up the associated Sofa data</li>


<li>Getting a reference to an existing
View and its associated Sofa, by name </li>


<li>Specifying a view in which to
index a particular Feature Structure instance
</li></ul>

<h3><a id="_crossRef307">Component XML metadata</a></h3>

<p>Each Multi-View component that creates a Sofa or wants to
switch to a specific previously created Sofa must declare the name for the Sofa
in the capabilities section. For example, a component expecting as input a web
document in html format and creating a plain text document for further
processing might declare:</p>

<p class="xmp" style='margin-top:0in;margin-right:0in;margin-bottom:0in;
margin-left:.8in;margin-bottom:.0001pt'>&lt;capabilities&gt;<br/>
  &lt;capability&gt;<br/>
    &lt;inputs/&gt;<br/>
    &lt;outputs/&gt;<br/>
    &lt;inputSofas&gt;</p>

<p class="xmp" style='margin-top:0in;margin-right:0in;margin-bottom:0in;
margin-left:57.55pt;margin-bottom:.0001pt'><b>      &lt;sofaName&gt;rawContent&lt;/sofaName&gt;</b></p>

<p class="xmp" style='margin-top:0in;margin-right:0in;margin-bottom:0in;
margin-left:.8in;margin-bottom:.0001pt'>    &lt;/inputSofas&gt;<br/>
    &lt;outputSofas&gt;<br/>
 <b>     &lt;sofaName&gt;detagContent&lt;/sofaName&gt;<br/>
</b>    &lt;/outputSofas&gt;<br/>
  &lt;/capability&gt;<br/>
&lt;/capabilities&gt;</p>

<p>Details on this specification are found reference chapter
section on <b><a class="crossrefText" href="Component_Descriptor_Reference.htm#_crossRef134">Capabilities</a></b> <a class="crossrefPage" href="Component_Descriptor_Reference.htm#_crossRef134"></a>. The Component Descriptor Editor supports Sofa
declarations on the <b><a class="crossrefText" href="Component_Descriptor_Editor_Users_Guide.htm#_crossRef109">Capabilities Page</a></b> (page <a class="crossrefPage" href="Component_Descriptor_Editor_Users_Guide.htm#_crossRef109">12-226</a>).</p>




  </subsection>
<subsection name="Sofa Capabilities and APIs for Applications"><a id="_crossRef308"> </a>



<p>In addition to components, applications can make use of
these capabilities.  When an application
creates a new CAS, it also creates the initial view of that CAS - and this view
is the object that is returned from the create call.  Additional views beyond this first one can be
dynamically created at any time. The application can use the Sofa APIs
described in <a class="crossrefText" href="SOFA_Developers_Guide.htm#_crossRef286">Chapter
8  </a>to specify the data to be analyzed.</p>

<p>If an Application creates a new CAS, the initial CAS that
is created will be a view named &quot;_InitialView&quot;.  This name can be used in the application and
in Sofa Mapping (see <b><a class="crossrefText" href="SOFA_Developers_Guide.htm#_crossRef309">Sofa
Name Mapping</a></b> <a class="crossrefPage" href="SOFA_Developers_Guide.htm#_crossRef309"></a>) to refer to this otherwise unnamed view.</p>




  </subsection>
<subsection name="Sofa Name Mapping"><a id="_crossRef309"> </a>



<p>Sofa Name mapping is the mechanism which enables UIMA
component developers to choose locally meaningful Sofa names in their source
code and let aggregate, collection processing engine developers, and
application developers connect output Sofas created in one component to input
Sofas required in another.</p>

<p>At a given aggregation level, the assembler or application
developer defines names for all the Sofas, and then specifies how these names
map to the contained components, using the Sofa Map.  </p>

<p>Consider annotator code to create a new CAS view:</p>

<p class="xmp" style='margin-top:0in;margin-right:0in;margin-bottom:0in;
margin-left:.8in;margin-bottom:.0001pt'>CAS viewX =
cas.createView(&quot;X&quot;);</p>

<p>Or code to get an existing CAS view:</p>

<p class="xmp">CAS viewX = cas.getView(&quot;X&quot;);</p>

<p>Without Sofa name mapping the SofaID for the new Sofa will
be &ldquo;X&rdquo;. However, if a name mapping for &ldquo;X&rdquo; has been specified by the aggregate
or CPE calling this annotator, the actual SofaID in the CAS can be different.</p>

<p>All Sofas in a CAS must have unique names. This is
accomplished by mapping all declared Sofas as described in the following
sections.  An attempt to create a Sofa
with a SofaID already in use will throw an exception.</p>

<p>Name mapping must not use the &quot;.&quot; (period)
character.  Runtime Sofa mapping maps
names up to the &quot;.&quot; and appends the period and the following
characters to the mapped name.</p>

<h3><a id="_crossRef310">Name Mapping in an Aggregate
Descriptor</a></h3>

<p>For each component of an Aggregate, name mapping specifies
the conversion between component Sofa names and names at the aggregate
level.  </p>

<p>Here's an example. Consider two Multi-View annotators to
be assembled into an aggregate which takes an audio segment consisting of
spoken English and produces a German text translation.</p>

<p>The first annotator takes an audio segment as input Sofa
and produces a text transcript as output Sofa. The annotator designer might
choose these Sofa names to be &ldquo;AudioInput&quot; and &ldquo;TranscribedText&quot;. </p>

<p>The second annotator is designed to translate text from
English to German. This developer might choose the input and output Sofa names
to be &ldquo;EnglishDocument&quot; and &ldquo;GermanDocument&quot;, respectively.</p>

<p>In order to hook these two annotators together, the
following section would be added to the top level of the aggregate descriptor:</p>

<p class="xmp">&lt;sofaMappings&gt;
  &lt;sofaMapping&gt;
    &lt;componentKey&gt;SpeechToText&lt;/componentKey&gt;
    &lt;componentSofaName&gt;AudioInput&lt;/componentSofaName&gt;
    &lt;aggregateSofaName&gt;SegementedAudio&lt;/aggregateSofaName&gt;
  &lt;/sofaMapping&gt;
  &lt;sofaMapping&gt;
    &lt;componentKey&gt;SpeechToText&lt;/componentKey&gt;
    &lt;componentSofaName&gt;TranscribedText&lt;/componentSofaName&gt;
    &lt;aggregateSofaName&gt;EnglishTranscript&lt;/aggregateSofaName&gt;
  &lt;/sofaMapping&gt;
  &lt;sofaMapping&gt;
    &lt;componentKey&gt;EnglishToGermanTranslator&lt;/componentKey&gt;
    &lt;componentSofaName&gt;EnglishDocument&lt;/componentSofaName&gt;
    &lt;aggregateSofaName&gt;EnglishTranscript&lt;/aggregateSofaName&gt;
  &lt;/sofaMapping&gt;
  &lt;sofaMapping&gt;
    &lt;componentKey&gt;EnglishToGermanTranslator&lt;/componentKey&gt;
    &lt;componentSofaName&gt;GermanDocument&lt;/componentSofaName&gt;
    &lt;aggregateSofaName&gt;GermanTranslation&lt;/aggregateSofaName&gt;
  &lt;/sofaMapping&gt;
&lt;/sofaMappings&gt;</p>

<p>The Component Descriptor Editor supports Sofa name mapping
in aggregates and simplifies the task. See <b><a class="crossrefText" href="Component_Descriptor_Editor_Users_Guide.htm#_crossRef110">Sofa name mappings</a></b> <a class="crossrefPage" href="Component_Descriptor_Editor_Users_Guide.htm#_crossRef110"></a> for details.<code></code></p>

<h3><a id="_crossRef311">Name Mapping in a CPE Descriptor</a></h3>

<p>The CPE descriptor aggregates together a Collection Reader
and CAS Processors (Annotators and CAS Consumers).  Sofa mappings can be added to the following
elements of CPE descriptors: <code>&lt;collectionIterator&gt;</code>,
<code>&lt;casInitializer&gt;</code> and the <code>&lt;casProcessor&gt;</code>.
To be consistent with the organization of CPE descriptors, the maps for the CPE
descriptor are distributed among the XML markup for each of the parts
(collectionIterator, casInitializer, casProcessor).  Because of this the<code>
&lt;componentKey&gt;</code> element is not needed.  Finally, rather than sub-elements for the
parts, the XML markup for these uses attributes.  See <b><a class="crossrefText" href="CPE_Descriptor_Reference.htm#_crossRef171">&lt;sofaNameMappings&gt; Element</a></b> <a class="crossrefPage" href="CPE_Descriptor_Reference.htm#_crossRef171"></a>.</p>

<p>Here's an example.  Let&rsquo;s use the aggregate from the previous section in a collection
processing engine. Here we will add a Collection Reader that outputs audio
segments in an output Sofa named &ldquo;nextSegment&quot;. Remember to declare an
output Sofa nextSegment in the collection reader description. We&rsquo;ll add a CAS
Consumer in the next section.</p>

<p class="xmp">&lt;collectionReader&gt;
  &lt;collectionIterator&gt;
    &lt;descriptor&gt;
    . . .
    &lt;/descriptor&gt;
    &lt;configurationParameterSettings&gt;...&lt;/configurationParameterSettings&gt;
<b>    &lt;sofaNameMappings&gt;
      &lt;sofaNameMapping componentSofaName=&quot;nextSegment&quot;
                       cpeSofaName=&quot;SegementedAudio&quot;/&gt;
      &lt;/sofaNameMappings&gt;
</b>  &lt;/collectionIterator&gt;
  &lt;casInitializer/&gt;
&lt;collectionReader&gt;</p>

<p>At this point the CAS Processor section for the aggregate
does not need any Sofa mapping because the aggregate input Sofa has the same
name, &quot;SegementedAudio&quot;, as is being produced by the Collection
Reader.</p>

<h3><a id="_crossRef312">Specifying the CAS View for a
Single-View Component</a></h3>

<p>Single-View components receive a Sofa named &quot;_InitialView&quot;,
or a Sofa that is mapped to this name.    </p>

<p>For example, assume that the CAS Consumer to be used in
our CPE is a Single-View component that expects the analysis results associated
with the input CAS, and that we want it to use the results from the translated
German text Sofa. The following mapping added to the CAS Processor section for
the CPE will instruct the CPE to get the CAS view for the German text Sofa and
pass it to the CAS Consumer:</p>

<p class="xmp">&lt;casProcessor&gt;
  . . .
  <b>&lt;sofaNameMappings&gt;
    &lt;sofaNameMapping componentSofaName=&quot;_InitialView&quot;
                           cpeSofaName=&quot;GermanTranslation&quot;/&gt;
  &lt;sofaNameMappings&gt;
</b>&lt;/casProcessor&gt;</p>

<p><a id="_crossRef313">An alternative syntax for this
kind of mapping is to simply leave out the component sofa name in this case.</a></p>

<h3><a id="_crossRef314">Name Mapping in a UIMA Application</a></h3>

<p>Applications which instantiate UIMA components directly
using the UIMAFramework methods can also create a top level Sofa mapping using
the &ldquo;additional parameters&quot; capability.</p>

<p class="xmp">//create a &quot;root&quot; UIMA context for your whole application</p>

<p class="xmp">UimaContext rootContext =
   UIMAFramework.newUimaContext(UIMAFramework.getLogger(),
      UIMAFramework.newDefaultResourceManager(),
      UIMAFramework.newConfigurationManager());</p>

<p class="xmp">input = new XMLInputSource(&quot;test.xml&quot;);
desc = UIMAFramework.getXMLParser().parseAnalysisEngineDescription(input);</p>

<p class="xmp">//setup sofa name mappings using the api</p>

<p class="xmp">HashMap sofamappings = new HashMap();
sofamappings.put(&quot;localName1&quot;,&quot;globalName1&quot;);
sofamappings.put(&quot;localName2&quot;,&quot;globalName2&quot;);</p>

<p class="xmp">//create a UIMA Context for the new AE we are about to create</p>

<p class="xmp">//first argument is unique key among all AEs used in the application
UimaContextAdmin childContext = uimaContext.createChild(&quot;myAE&quot;, sofamap);</p>

<p class="xmp">//instantiate AE, passing the UIMA Context through the additional
//parameters map</p>

<p class="xmp">Map additionalParams = new HashMap();
additionalParams.put(Resource.PARAM_UIMA_CONTEXT, childContext);</p>

<p class="xmp">anAnnotator = UIMAFramework.produceAnalysisEngine(desc,additionalParams);</p>

<p>Sofa mappings are applied from the inside out, i.e., local
to global.  First, any aggregate mappings
are applied, then any CPE mappings, and finally, any specified using this
&quot;additional parameters&quot; capability.</p>

<h3><a id="_crossRef315">Name Mapping for Remote Services</a></h3>

<p>Currently, no client-side Sofa mapping information is
passed from a UIMA client to a remote service. This can cause complications for
UIMA services in a Multi-View application. </p>

<p>Remote services using the SOAP transport will work only if
the service is Single-View, or if the Sofa names expected by the service match
the Sofa names produced by the client.</p>

<p>Sofa name mapping is supported when running in
&quot;integrated&quot; CPM mode (or without the CPM) using Vinci, by renaming
the Sofas specified by the service descriptor, if necessary.</p>




  </subsection>
<subsection name="JCas extensions for Multiple Views / Sofas"><a id="_crossRef316"> </a>



<p>The JCas
interface to the CAS can be used with any / all views, as well as the base CAS
sent to Multi-View components.  You can
always get a JCas object from an existing CAS object by using the method
getJCas(); this call will create the JCas if it doesn't already exist.  If it does exist, it just returns the
existing JCas that corresponds to the CAS.  </p>

<p>JCas implements
the getView(...) method, enabling switching to other named views, just like the
corresponding method on the CAS.  The
JCas version, however, returns JCas objects, instead of CAS objects,
corresponding to the view.</p>




  </subsection>
<subsection name="Sample Multi-View Application"><a id="_crossRef317"> </a>



<p>The UIMA SDK contains a simple Sofa example application
which demonstrates many Sofa specific concepts and methods. The source code for
the application driver is in <code>docs/examples/src/com/ibm/uima/examples/SofaExampleApplication.java</code>
and the Multi-View annotator is given in <code>SofaExampleAnnotator.java</code>
in the same directory.</p>

<p>This sample application demonstrates a language translator
annotator which expects an input text Sofa with an English document and creates
an output text Sofa containing a German translation. Some of the key Sofa
concepts illustrated here include:</p>

<ul class="compact"><li>Sofa creation.</li>


<li>Access of multiple CAS views.</li>


<li>Unique feature structure index
space for each view.</li>


<li>Feature structures containing
cross references between annotations in different CAS views.</li>


<li>The strong affinity of annotations
with a specific Sofa.
</li></ul>

<p><b>Annotator Descriptor</b></p>

<p>The annotator descriptor in <code>docs/examples/descriptors/analysis_engine/SofaExampleAnnotator.xml</code>
declares an input Sofa named &quot;EnglishDocument&quot; and an output Sofa
named &ldquo;GermanDocument&quot;. A custom type &ldquo;CrossAnnotation&quot; is also
defined:</p>

<p><code>&lt;typeDescription&gt;<br/>
  &lt;name&gt;sofa.test.CrossAnnotation&lt;/name&gt;<br/>
  &lt;description/&gt;<br/>
  &lt;supertypeName&gt;uima.tcas.Annotation&lt;/supertypeName&gt;<br/>
  &lt;features&gt;<br/>
    &lt;featureDescription&gt;<br/>
      &lt;name&gt;otherAnnotation&lt;/name&gt;<br/>
      &lt;description/&gt;<br/>
      &lt;rangeTypeName&gt;uima.tcas.Annotation&lt;/rangeTypeName&gt;<br/>
    &lt;/featureDescription&gt;<br/>
  &lt;/features&gt;<br/>
&lt;/typeDescription&gt;</code></p>

<p>The <code>CrossAnnotation</code> type is
derived from <code>uima.tcas.Annotation </code>and includes one
new feature: a reference to another annotation.</p>

<p><b>Application Setup</b></p>

<p>The application driver instantiates an analysis engine, <code>seAnnotator</code>, from the annotator descriptor, obtains a new
base CAS using that engine&rsquo;s CAS definition, and creates the expected input
Sofa using:</p>

<p><code>CAS cas = seAnnotator.newCAS();<br/>
CAS aView = cas.createView(&quot;EnglishDocument&quot;);</code></p>

<p>Since <code>seAnnotator</code> is a
primitive component, and no Sofa mapping has been defined, the SofaID will be
&ldquo;EnglishDocument&quot;. Local Sofa data is set using:</p>

<p><code>aView.setDocumentText(&quot;this beer
is good&quot;);</code></p>

<p>At this point the CAS contains all necessary inputs for
the translation annotator and its process method is called.</p>

<p><b>Annotator Processing</b></p>

<p>Annotator processing consists of parsing the English
document into individual words, doing word-by-word translation and
concatenating the translations into a German translation. Analysis metadata on
the English Sofa will be an annotation for each English word. Analysis metadata
on the German Sofa will be a <code>CrossAnnotation</code> for
each German word, where the <code>otherAnnotation</code> feature
will be a reference to the associated English annotation.</p>

<p>Code of interest includes two CAS views:</p>

<p class="xmp">// get View of the English text Sofa
engView = aCas.getView(&quot;EnglishDocument&quot;);

// Create the output German text Sofa
germView = aCas.createView(&quot;GermanDocument&quot;);</p>

<p>the indexing of annotations with the appropriate view:</p>

<p class="xmp">engView.addFsToIndexes(engAnnot);
. . .
germView.addFsToIndexes(germAnnot);</p>

<p>and the combining of metadata belonging to different Sofas
in the same feature structure:</p>

<p class="xmp">// add link to English text
germAnnot.setFeatureValue(other, engAnnot);</p>

<p><b>Back in the Application, accessing the results of
analysis</b></p>

<p>Analysis results for each Sofa are dumped independently by
iterating over all annotations for each associated CAS view. For the English
Sofa:</p>

<p class="xmp">//get annotation iterator for this CAS
FSIndex anIndex = aView.getAnnotationIndex();
FSIterator anIter = anIndex.iterator();
while (anIter.isValid()) {
  AnnotationFS annot = (AnnotationFS) anIter.get();
  System.out.println(&quot; &quot; + annot.getType().getName()
                         + &quot;: &quot; + annot.getCoveredText());
  anIter.moveToNext();
}</p>

<p>Iterating over all German annotations looks the same,
except for the following:</p>

<p class="xmp">if (annot.getType() == cross) {
  AnnotationFS crossAnnot =
          (AnnotationFS) annot.getFeatureValue(other);
  System.out.println(&quot;   other annotation feature: &quot;
          + crossAnnot.getCoveredText());
}</p>

<p>Of particular interest here is the built-in Annotation
type method <code>getCoveredText()</code>. This method uses the
&ldquo;begin&quot; and &ldquo;end&quot; features of the annotation to create a substring
from the CAS document. The SofaRef feature of the annotation is used to
identify the correct Sofa's data from which to create the substring. </p>

<p>The example program output is:</p>

<p class="xmp">---Printing all annotations for English Sofa---
uima.tcas.DocumentAnnotation: this beer is good
uima.tcas.Annotation: this
uima.tcas.Annotation: beer
uima.tcas.Annotation: is
uima.tcas.Annotation: good</p>

<p class="xmp">---Printing all annotations for German Sofa---
uima.tcas.DocumentAnnotation: das bier ist gut
sofa.test.CrossAnnotation: das
  other annotation feature: this
sofa.test.CrossAnnotation: bier
  other annotation feature: beer
sofa.test.CrossAnnotation: ist
  other annotation feature: is
sofa.test.CrossAnnotation: gut
  other annotation feature: good</p>




  </subsection>
<subsection name="Sofa API Summary"><a id="_crossRef318"> </a>



<p>The recommended way to deliver a particular CAS view to a <b><i>Single-View</i></b>
component is to use by Sofa-mapping in the CPE and/or aggregate descriptors.</p>

<p>For <b><i>Multi-View </i></b>components or applications, the
following methods are used to create or get a reference to a CAS view for a
particular Sofa: </p>

<p>Creating a new View:</p>

<p class="xmp">JCas newView = aJCas.createView(String localNameOfTheViewBeforeMapping);
CAS  newView = aCAS .createView(String localNameOfTheViewBeforeMapping);</p>

<p>Getting a View from a CAS or JCas:</p>

<p class="xmp">JCas myView = aJCas.getView(String localNameOfTheViewBeforeMapping);
CAS  myView = aCAS .getView(String localNameOfTheViewBeforeMapping);</p>

<p>The following methods are useful for all annotators and
applications:</p>

<p>Setting Sofa data for a CAS or JCas:</p>

<p class="xmp" style='margin-top:0in;margin-right:0in;margin-bottom:0in;
margin-left:.8in;margin-bottom:.0001pt'>aCasOrJCas.setDocumentText(String
docText);</p>

<p class="xmp" style='margin-top:0in;margin-right:0in;margin-bottom:0in;
margin-left:.8in;margin-bottom:.0001pt'>aCasOrJCas.setSofaDataString(String
docText, String mimeType);</p>

<p class="xmp" style='margin-top:0in;margin-right:0in;margin-bottom:0in;
margin-left:.8in;margin-bottom:.0001pt'>aCasOrJCas.setSofaDataArray(FeatureStructure
array, String mimeType);</p>

<p class="xmp" style='margin-top:0in;margin-right:0in;margin-bottom:0in;
margin-left:.8in;margin-bottom:.0001pt'>aCasOrJCas.setSofaDataURI(String uri, String mimeType);</p>

<p>Getting Sofa data for a particular CAS or JCas:</p>

<p class="xmp" style='margin-top:0in;margin-right:0in;margin-bottom:0in;
margin-left:.8in;margin-bottom:.0001pt'>String doc = aCasOrJCas.getDocumentText();<br/>
String doc = aCasOrJCas.getSofaDataString();</p>

<p class="xmp" style='margin-top:0in;margin-right:0in;margin-bottom:0in;
margin-left:.8in;margin-bottom:.0001pt'>FeatureStructure array =
aCasOrJCas.getDataArray();</p>

<p class="xmp" style='margin-top:0in;margin-right:0in;margin-bottom:0in;
margin-left:.8in;margin-bottom:.0001pt'>String uri = aCasOrJCas.getDataURI();</p>

<p class="xmp" style='margin-top:0in;margin-right:0in;margin-bottom:0in;
margin-left:.8in;margin-bottom:.0001pt'>InputStream is = aCasOrJCas.getSofaDataStream();</p>

<p class="xmp" style='margin-top:0in;margin-right:0in;margin-bottom:0in;
margin-left:.8in;margin-bottom:.0001pt'></p>




  </subsection>
<subsection name="Sofa Incompatibilities between UIMA v1.x and v2.0"><a id="_crossRef319"> </a>



<p>The major change for v2.0 is related to the support of
Single-View components and applications. Given an analysis engine, <code>ae</code>, the API</p>

<p class="xmp" style='margin-top:0in;margin-right:0in;margin-bottom:0in;
margin-left:.8in;margin-bottom:.0001pt'>CAS cas = ae.newCas();</p>

<p>used to return the base CAS. Now it returns a view of the
Sofa named &ldquo;_InitialView&rdquo;. This Sofa will actually only be created if any Sofa
data is set for this view. The initial view is used for Single-View
applications and Multi-View annotators with no Sofa mapping.</p>

<p>The process method of Multi-View annotators receive the
base CAS, however the base CAS no longer has an index repository to hold
&ldquo;global&rdquo; data.  Global data needs to be
put in a specific named CAS view of your choice.</p>

<p>Because of these changes, the following scenarios will
break with v2.0 clients:</p>

<ul class="compact"><li>Any version 1.x services (you must
migrate the services to version 2).</li>


<li>Applications or components
explicitly referencing &quot;_DefaultTextSofaName&quot; in code or descriptors.</li>


<li>Multi-View applications using the
Base CAS index repository.
</li></ul>

</div>
<div class="footnotesHere"></div>
</div>



  </subsection>

</section>
</body>
</document>
