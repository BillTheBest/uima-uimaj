<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.4//EN"
"http://www.oasis-open.org/docbook/xml/4.4/docbookx.dtd"[
<!ENTITY imgroot "images/annotator_analysis_engine_files/" >
<!ENTITY % uimaents SYSTEM "entities.ent" >  
%uimaents;
]>
<!--
Licensed to the Apache Software Foundation (ASF) under one
or more contributor license agreements.  See the NOTICE file
distributed with this work for additional information
regarding copyright ownership.  The ASF licenses this file
to you under the Apache License, Version 2.0 (the
"License"); you may not use this file except in compliance
with the License.  You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing,
software distributed under the License is distributed on an
"AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, either express or implied.  See the License for the
specific language governing permissions and limitations
under the License.
-->
<chapter id="ugr.ref.xml.component_descriptor">
  <title></title>
  <section name="Component Descriptor Reference"><a id="_crossRef120"> </a>



<para>This chapter is the reference guide for the UIMA SDK&apos;s
Component Descriptor XML schema.  A <emphasis>Component
Descriptor</emphasis> (also sometimes called a <emphasis>Resource Specifier</emphasis> in the code)
is an XML file that either (a) completely describes a component, including all
information needed to construct the component and interact with it, or (b)
specifies how to connect to and interact with an existing component that has
been published as a remote service.  <emphasis>Component</emphasis>
(also called <emphasis>Resource</emphasis>) is a general term for modules produced by UIMA
developers and used by UIMA applications.  The types of Components are: Analysis Engines, Collection Readers, CAS
Initializers, CAS Consumers, and Collection Processing Engines.  However, Collection Processing Engine Descriptors
are significantly different in format and are covered in a separate chapter, <emphasis>UIMA
Collection Processing Engine Descriptor Reference.</emphasis></para>

<para>Section <a class="crossrefText" href="Component_Descriptor_Reference.htm#_crossRef121">23.1
</a> describes the
notation used in this chapter.</para>

<para>Section <a class="crossrefText" href="Component_Descriptor_Reference.htm#_crossRef122">23.2
</a> describes the
UIMA SDK&apos;s <emphasis>import</emphasis> syntax, used to allow XML descriptors to import
information from other XML files, to allow sharing of information between
several XML descriptors.</para>

<para>Section <a class="crossrefText" href="Component_Descriptor_Reference.htm#_crossRef125">23.4
</a> describes the
XML format for <emphasis>Analysis Engine Descriptors</emphasis>.  These are descriptors that completely
describe Analysis Engines, including all information needed to construct and
interact with them.</para>

<para>Section <a class="crossrefText" href="Component_Descriptor_Reference.htm#_crossRef146">23.6
</a> describes the
XML format for <emphasis>Collection Processing Component Descriptors</emphasis>.  This includes Collection Iterator, CAS
Initializer, and CAS Consumer Descriptors.</para>

<para>Section <a class="crossrefText" href="Component_Descriptor_Reference.htm#_crossRef151">23.7
</a> describes the
XML format for <emphasis>Service Client Descriptors</emphasis>, which specify how to connect
to and interact with resources deployed as remote services.</para>



<subsection name="Notation"><a id="_crossRef121"> </a>



<para>This chapter uses
an informal notation to specify the syntax of Component Descriptors.  The formal syntax is defined by an XML schema
definition, which is contained in two files &ndash; <literal>resourceSpecifierSchema.xsd</literal> and <literal>TaeSpecifierSchema.xsd</literal>,
both of which are in the <literal>uima_core.jar</literal> file.</para>

<para>The notation used
in this chapter is:</para>

<itemizedlist><listitem>An ellipsis (...) inside an
element body indicates that the substructure of that element has been omitted
(to be described in another section of this chapter). An example of this would
be:
</listitem></itemizedlist>

<programlisting>&lt;analysisEngineMetaData&gt;</programlisting>

<programlisting>...</programlisting>

<programlisting>&lt;/analysisEngineMetaData&gt;</programlisting>

<itemizedlist><listitem>An ellipsis immediately after an
element indicates that the element type may be may be repeated arbitrarily many
times.  For example:
</listitem></itemizedlist>

<programlisting>&lt;parameter&gt;[String]&lt;/parameter&gt;
&lt;parameter&gt;[String]&lt;/parameter&gt;
...</programlisting>

<p class="StyleBodyTextLeft8">indicates
that there may be arbitrarily many parameter elements in this context.</p>

<itemizedlist><listitem>Bracketed expressions (e.g. <literal>[Str</literal><literal>ing]</literal>)
indicate the type of value that may be used at that location.</listitem>


<listitem>A vertical bar, as in <literal>true|false</literal>,
indicates alternatives. This can be applied to literal values, bracketed type
names, and elements.</listitem>


<listitem>Which elements are optional and
which are required is specified in prose, not in the syntax definition.
</listitem></itemizedlist>




  </subsection>
<subsection name="Imports"><a id="_crossRef122"> </a>



<para>The UIMA SDK defines a particular syntax for XML
descriptors to import information from other XML files.  When one of the following appears in an XML
descriptor:</para>

<programlisting>&lt;import location=<quote>[URL]</quote> /&gt; or</programlisting>

<programlisting>&lt;import name=<quote>[Name]</quote> /&gt;   </programlisting>

<para>it indicates that information from a separate XML file is
being imported.  Note that imports are
allowed only in certain places in the descriptor.  In the remainder of this chapter, it will be
indicated at which points imports are allowed.</para>

<para>If an import specifies a <literal>location</literal>
attribute, the value of that attribute specifies the URL at which the XML file
to import will be found.  This can be a
relative URL, which will be resolved relative to the descriptor containing the <literal>import</literal> element, or an absolute URL.  Relative URLs can be written without a
protocol/scheme (e.g., <quote>file:</quote>), and without a host machine name. In
this case the relative URL might look something like <literal>org/apache/myproj/MyTypeSystem.xml.</literal></para>

<para>An absolute URL is written with one of the following
prefixes, followed by a path such as <literal>org/apache/myproj/MyTypeSystem.xml</literal>:</para>

<itemizedlist spacing="compact"><listitem><para>file:/ &larr; has no network address</para></listitem>

<listitem><para>file:/// &larr; has an empty network address</para></listitem>

<listitem><para>file://some.network.address/</para></listitem></itemizedlist>

<para>For more information about URLs, please read the javadoc
information for the Java class <quote>URL</quote>.</para>

<para>If an import specifies a <literal>name</literal>
attribute, the value of that attribute should take the form of a Java-style
dotted name (e.g. <literal>org.apache.myproj.MyTypeSystem</literal>).  An .xml file with this name will be searched
for in the classpath or datapath (described below).  As in Java, the dots in the name will be
converted to file path separators.  So an
import specifying the example name in this paragraph will result in a search
for <literal>org/apache/myproj/MyTypeSystem.xml</literal> in the classpath
or datapath.</para>

<para>The datapath works similarly to the classpath but can be
set programmatically through the resource manager API.  Application developers can specify a datapath
during initialization, using the following code:

<programlisting>
ResourceManager resMgr = UIMAFramework.newDefaultResourceManager();
resMgr.setDataPath(yourPathString);
AnalysisEngine ae = UIMAFramework.produceAE(desc, resMgr, null);
</programlisting></para>

<para>The default datapath for the entire JVM can be set via the
<literal>uima.datapath</literal> Java system property, but this feature
should only be used for standalone applications that don&apos;t need to run in the
same JVM as other code that may need a different datapath.</para>

<para>The UIMA SDK also supports XInclude, a W3C candidate recommendation,
to include XML files within other XML files.  However, it is recommended that the import syntax be used instead, as it
is more flexible and better supports tool developers.</para>

<note>UIMA tools for editing XML
descriptors do not support the use of xi:include because they cannot correctly
determine what parts of a descriptor are updatable, and what parts are included
from other files.  They do support the
use of &lt;import&gt;.
</listitem></itemizedlist>

<para>To use XInclude, you first must include the XInclude
namespace in your document&apos;s root element, e.g.:</para>

<programlisting>&lt;analysisEngineDescription xmlns=<quote>http://uima.apache.org/resourceSpecifier</quote> xmlns:xi=<quote>http://www.w3.org/2001/XInclude</quote>&gt;</programlisting>

<para>Then, you can include a file using the syntax <literal>&lt;xi:include
href=<quote>[URL]</quote>/&gt;</literal></para>

<para>where [URL] can be any relative or absolute URL referring
to another XML document.  The referred-to
document must be a valid XML document, meaning that it must consist of exactly
one root element and must define all of the namespace prefixes that it uses.  The default namespace (generally <literal>http://uima.apache.org/resourceSpecifier</literal>) will be
inherited from the parent document.   When UIMA parses the XML document, it will automatically replace the <literal>&lt;xi:include&gt; </literal>element with the entire XML document
referred to by the href.  For more
information on XInclude see <a href="http://www.w3.org/TR/xinclude/">http://www.w3.org/TR/xinclude/</a>.</para>




  </subsection>
<subsection name="Type System Descriptors"><a id="_crossRef123"> </a>



<para>A Type System Descriptor is used to define the types and
features that can be represented in the CAS.  A Type System Descriptor can be imported into an Analysis Engine or
Collection Processing Component Descriptor.</para>

<para>The basic structure of a Type System Descriptor is as
follows:</para>

<programlisting>&lt;typeSystemDescription xmlns=<quote>http://uima.apache.org/resourceSpecifier</quote>&gt;</programlisting>

<programlisting>  &lt;name&gt; [String] &lt;/name&gt;
  &lt;description&gt;[String]&lt;/description&gt;
  &lt;version&gt;[String]&lt;/version&gt;
  &lt;vendor&gt;[String]&lt;/vendor&gt; </programlisting>

<programlisting>  &lt;imports&gt;
    &lt;import ...&gt;
    ...
  &lt;/imports&gt; </programlisting>

<programlisting>  &lt;types&gt;
    &lt;typeDescription&gt;
      ...
    &lt;/typeDescription&gt;</programlisting>

<programlisting>    ...</programlisting>

<programlisting>  &lt;/types&gt;</programlisting>

<programlisting>&lt;/typeSystemDescription&gt;</programlisting>

<para>All of the subelements are optional.</para>

<h4>Imports</h4>

<para>The <literal>imports</literal> section allows this descriptor to import types
from other type system descriptors.  The
import syntax is described in section <a class="crossrefText" href="Component_Descriptor_Reference.htm#_crossRef121">23.1
</a> of this chapter.  A type system may import any number of other
type systems and then define additional types which refer to imported
types.  Circular imports are allowed.</para>

<h4>Types</h4>

<para>The <literal>types</literal> element contains zero or more <literal>typeDescription</literal>
elements.  Each <literal>typeDescription</literal> has the
form:</para>

<programlisting>&lt;typeDescription&gt;
  &lt;name&gt;[TypeName]&lt;/name&gt;
  &lt;description&gt;[String]&lt;/description&gt;
  &lt;supertypeName&gt;[TypeName]&lt;/supertypeName&gt;
  &lt;features&gt;
    ...
  &lt;/features&gt;
&lt;/typeDescription&gt;</programlisting>

<para>The name element contains the name of the type.  A <literal>[TypeName]</literal> is a dot-separated list of names, where each
name consists of a letter followed by any number of letters, digits, or
underscores.  <literal>TypeNames</literal> are case
sensitive. Letter and digit are as defined by Java; therefore, any Unicode
letter or digit may be used (subject to the character encoding defined by the
descriptor file&apos;s XML header).  The name
following the final dot is considered to be the <quote>short name</quote> of the
type; the preceding portion is the namespace (analogous to the package.class
syntax used in Java).  Namespaces
beginning with uima are reserved and should not be used.  Examples of valid type names are:</para>

<itemizedlist spacing="compact"><listitem>test.TokenAnnotation</listitem>


<listitem>org.myorg.tae.TokenAnnotation</listitem>


<listitem>com.my_company.proj123.TokenAnnotation
</listitem></itemizedlist>

<para>These would all be considered distinct types since they
have different namespaces.  Best practice
here is to follow the normal Java naming conventions of having namespaces be
all lowercase, with the short type names having an initial capital, but this is
not mandated, so <literal>ABC.mYtyPE</literal>
is an allowed type name.  While type
names without namespaces (e.g. <literal>TokenAnnotation</literal> alone) are allowed, the JCas does not
support them and so their use is strongly discouraged.</para>

<para>The <literal>description</literal> element contains a textual description of the
type.  The <literal>superTypeName</literal>
element contains the name of the type from which it inherits (this can be set
to the name of another user-defined type, or it may be set to any built-in type
which may be subclassed, such as <literal><quote>uima.tcas.Annotation</quote></literal> for a new annotation
type or <literal><quote>uima.cas.TOP</quote></literal>
for a new type that is not an annotation).  All three of these elements are required.</para>

<h4><a id="_crossRef124">Features</a></h4>

<para>The <literal>features</literal> element of a <literal>typeDescription</literal> is required only if the type we are
specifying introduces new features.  If
the <literal>features</literal>
element is present, it contains zero or more <literal>featureDescription</literal>
elements, each of which has the form:</para>

<programlisting>&lt;featureDescription&gt;
  &lt;name&gt;[Name]&lt;/name&gt;
  &lt;description&gt;[String]&lt;/description&gt;
  &lt;rangeTypeName&gt;[Name]&lt;/rangeTypeName&gt;
  &lt;elementType&gt;[Name]&lt;/elementType&gt;
  &lt;multipleReferencesAllowed&gt;true|false&lt;/multipleReferencesAllowed&gt;
&lt;/featureDescription&gt;</programlisting>

<para>A feature&apos;s name follows the same rules as a type short
name &ndash; a letter followed by any number of letters, digits, or underscores.  Feature names are case sensitive.</para>

<para>The feature&apos;s <literal>rangeTypeName</literal> specifies
the type of value that the feature can take.  This may be the name of any type defined in your type system, or one of
the predefined types.  All of the
predefined types have names that are prefixed with <literal>uima.cas</literal> or <literal>uima.tcas</literal>,
for example:</para>

<programlisting>uima.cas.TOP 
uima.cas.String
uima.cas.Boolean 
uima.cas.Byte 
uima.cas.Short 
uima.cas.Long 
uima.cas.Float 
uima.cas.Double 
uima.cas.FSArray
uima.cas.StringArray
uima.cas.BooleanArray
uima.cas.ByteArray
uima.cas.ShortArray 
uima.cas.IntegerArray
uima.cas.LongArray
uima.cas.FloatArray
uima.cas.DoubleArray
uima.cas.FSList
uima.cas.StringList
uima.cas.IntegerList
uima.cas.FloatList
uima.tcas.Annotation.</programlisting>

<para>For a complete list of predefined types, see the CAS API
documentation.</para>

<para>The <literal>elementType</literal> of a feature is
optional, and applies only when the <literal>rangeTypeName</literal> is
<literal>uima.cas.FSArray</literal> or <literal>uima.cas.FSList</literal>  The <literal>elementType</literal>
specifies what type of value <literal>can be assigned as an element
of the array or list. This must be the name of a non-</literal>primitive
type.  If omitted, it defaults to <literal>uima.cas.TOP</literal>, meaning that any FeatureStructure can be
assigned as an element the array or list.  Note: depending on the CAS Interface that you use in your code, this
constraint may or may not be enforced.</para>

<para>The <literal>multipleReferencesAllowed</literal>
feature is optional, and applies only when the <literal>rangeTypeName</literal>
is an array or list type (it applies to arrays and lists of primitive as well
as non-primitive types).  Setting this to
false (the default) indicates that this feature has exclusive ownership of the
array or list, so changes to the array or list are localized. Setting this to
true indicates that the array or list may be shared, so changes to it may
affect other objects in the CAS.  Note:
there is currently no guarantee that the framework will enforce this restriction.  However, this setting may affect how the CAS
is serialized.</para>

<h4>String Subtypes</h4>

<para>There is one other special type that you can declare &ndash; a
subset of the String type that specifies a restricted set of allowed
values.  This is useful for features that
can have only certain String values, such as parts of speech.  Here is an example of how to declare such a
type:</para>

<programlisting>&lt;typeDescription&gt;
  &lt;name&gt;PartOfSpeech&lt;/name&gt;
  &lt;description&gt;A part of speech.&lt;/description&gt;
  &lt;supertypeName&gt;uima.cas.String&lt;/supertypeName&gt;
  &lt;allowedValues&gt;
    &lt;value&gt;
      &lt;string&gt;NN&lt;/string&gt;
      &lt;description&gt;Noun, singular or mass.&lt;/description&gt;
    &lt;/value&gt;
    &lt;value&gt;
      &lt;string&gt;NNS&lt;/string&gt;
      &lt;description&gt;Noun, plural.&lt;/description&gt;
    &lt;/value&gt;
    &lt;value&gt;
      &lt;string&gt;VB&lt;/string&gt;
      &lt;description&gt;Verb, base form.&lt;/description&gt;
    &lt;/value&gt;</programlisting>

<programlisting>    ...</programlisting>

<programlisting>  &lt;/allowedValues&gt;
&lt;/typeDescription&gt;</programlisting>






  </subsection>
<subsection name="Analysis Engine Descriptors"><a id="_crossRef125"> </a>



<para>Analysis Engine (AE) descriptors completely describe
Analysis Engines.  There are two basic
types of Analysis Engines &ndash; <emphasis>Primitive</emphasis> and <emphasis>Aggregate</emphasis>.  A <emphasis>Primitive</emphasis> Analysis Engine is a
container for a single <emphasis>annotator</emphasis>, where as an <emphasis>Aggregate</emphasis> Analysis
Engine is composed of a collection of other Analysis Engines.  (For more information on this and other
terminology, see <a class="crossrefText" href="UIMA Conceputal Overview.htm#_crossRef320">Chapter 2, <b>UIMA Conceptual Overview</b></a>)</para>

<para>Both Primitive and Aggregate Analysis Engines have
descriptors, and the two types of descriptors have some similarities and some
differences.  Primitive Analysis Engine
descriptors are discussed first, in Section <a class="crossrefText" href="Component_Descriptor_Reference.htm#_crossRef126">23.4.1
</a>.  Section <a class="crossrefText" href="Component_Descriptor_Reference.htm#_crossRef138">23.4.2
</a> then describes
how Aggregate Analysis Engine descriptors are different.</para>

<h3><a id="_crossRef126">Primitive Analysis Engine
Descriptors</a></h3>

<h4><a id="_crossRef127">Basic Structure</a></h4>

<programlisting>&lt;?xml version=<quote>1.0</quote> encoding=<quote>UTF-8</quote> ?&gt;
&lt;analysisEngineDescription xmlns=<quote>http://uima.apache.org/resourceSpecifier</quote>&gt;
  &lt;frameworkImplementation&gt;org.apache.uima.java&lt;/frameworkImplementation&gt; </programlisting>

<programlisting>  &lt;primitive&gt;true&lt;/primitive&gt;
  &lt;annotatorImplementationName&gt; [String] &lt;/annotatorImplementationName&gt;</programlisting>

<programlisting>  &lt;analysisEngineMetaData&gt;
    ...
  &lt;/analysisEngineMetaData&gt;</programlisting>

<programlisting>  &lt;externalResourceDependencies&gt;
    ...
  &lt;/externalResourceDependencies&gt;</programlisting>

<programlisting>  &lt;resourceManagerConfiguration&gt;
    ...
  &lt;/resourceManagerConfiguration&gt;</programlisting>

<programlisting>&lt;/analysisEngineDescription&gt;</programlisting>

<para>The document begins with a standard XML header.  The recommended root tag is <literal>&lt;analysisEngineDescription&gt;</literal>, although <literal>&lt;taeDescription&gt;</literal> is also allowed for backwards
compatibility.</para>

<para>Within the root element we declare that we are using the
XML namespace <literal>http://uima.apache.org/resourceSpecifier.</literal>  It is required that this namespace be used;
otherwise, the descriptor will not be able to be validated for errors.</para>

<para> The first
subelement, <literal>&lt;frameworkImplementation&gt;,</literal>
currently must have the value <literal>org.apache.uima.java</literal>, or <literal>org.apache.uima.cpp</literal>.  In
future versions, there may be other framework implementations, or perhaps
implementations produced by other vendors.</para>

<para>The second subelement, <literal>&lt;primitive&gt;,</literal>
contains the Boolean value <literal>true</literal>, indicating that
this XML document describes a <emphasis>Primitive</emphasis> Analysis Engine.</para>

<para>The next subelement,<literal> &lt;annotatorImplementationName&gt;</literal>
is how the UIMA framework determines which annotator class to use.  This should contain a fully-qualified Java
class name for Java implementations, or the name of a .dll or .so file for C++
implementations.</para>

<para>The <literal>&lt;analysisEngineMetaData&gt;</literal> object contains
descriptive information about the analysis engine and what it does.  It is described in the section <b><a class="crossrefText" href="Component_Descriptor_Reference.htm#_crossRef128">Analysis Engine
Metadata</a></b>.</para>

<para>The <literal>&lt;externalResourceDependencies&gt;</literal> and <literal>&lt;resourceManagerConfiguration&gt;</literal>
elements declare the <literal>external</literal> resource files that the analysis engine relies
upon.  They are optional and are
described in the section <b><a class="crossrefText" href="Component_Descriptor_Reference.htm#_crossRef135">External
Resource Dependencies</a></b> and <b><a class="crossrefText" href="Component_Descriptor_Reference.htm#_crossRef136">Resource
Manager Configuration</a></b>.</para>

<h4><a id="_crossRef128">Analysis
Engine Metadata</a></h4>

<programlisting>&lt;analysisEngineMetaData&gt;
  &lt;name&gt; [String] &lt;/name&gt;
  &lt;description&gt;[String]&lt;/description&gt;
  &lt;version&gt;[String]&lt;/version&gt;
  &lt;vendor&gt;[String]&lt;/vendor&gt;</programlisting>

<programlisting>  &lt;configurationParameters&gt; ...  &lt;/configurationParameters&gt;</programlisting>

<programlisting>  &lt;configurationParameterSettings&gt;
    ...
  &lt;/configurationParameterSettings&gt; </programlisting>

<programlisting>  &lt;typeSystemDescription&gt; ... &lt;/typeSystemDescription&gt; </programlisting>

<programlisting>  &lt;typePriorities&gt; ... &lt;/typePriorities&gt; </programlisting>

<programlisting>  &lt;fsIndexCollection&gt; ... &lt;/fsIndexCollection&gt;</programlisting>

<programlisting>  &lt;capabilities&gt; ... &lt;/capabilities&gt;</programlisting>

<programlisting>  &lt;operationalProperties&gt; ... &lt;/operationalProperties&gt;</programlisting>

<programlisting>&lt;/analysisEngineMetaData&gt;</programlisting>

<para>The <literal>analysisEngineMetaData</literal>
element contains four simple string fields &ndash; <literal>name</literal>, <literal>description</literal>, <literal>version</literal>, and <literal>vendor</literal>.  Only the <literal>name</literal> field is required, but providing values for the other
fields is recommended.  The <literal>name</literal> field is just a descriptive name meant to be read by
users; it does not need to be unique across all Analysis Engines.</para>

<para>The other sub-elements &ndash; <literal>configurationParameters</literal>,
<literal>configurationParameterSettings</literal>, <literal>typeSystemDescription</literal>,
<literal>typePriorities</literal>, <literal>fsIndexes</literal>,
<literal>capabilities</literal> and <literal>operationalProperties</literal>
are described in the following sections.  The only one of these that is required is <literal>capabilities</literal>;
the others are all technically optional but generally necessary for an analysis
engine of any complexity.</para>

<h4><a id="_crossRef129"><emphasis>Configuration Parameter Declaration</emphasis></a></h4>

<para>Configuration Parameters are made available to annotator
implementations and applications by the following interfaces: <literal>AnnotatorContext</literal> (passed as an argument to the initialize()
method of an annotator), <literal>ConfigurableResource</literal> (every
Analysis Engine implements this interface), and the <literal>UimaContext</literal>
(you can get this from any resource, including Analysis Engines, using the
method <literal>getUimaContext</literal>()).</para>

<para>Use AnnotatorContext within annotators and UimaContext
outside of annotators (for instance, in CasConsumers, or the containing
application) to access configuration parameters.</para>

<para>Configuration parameters are set from the corresponding
elements in the XML descriptor for the application.  If you need to programmatically change
parameter settings within an application, you can use methods in
ConfigurableResource; if you do this, you need to call reconfigure() afterwards
to have the UIMA framework notify all the contained analysis components that
the parameter configuration has changed (the analysis engine&apos;s reinitialize()
methods will be called).  Note that in
the current implementation, only integrated deployment components have
configuration parameters passed to them; remote components obtain their
parameters from their remote startup environment.  This will likely change in the future.</para>

<para>There are two ways to specify the <literal>&lt;configurationParameters&gt;</literal>
section &ndash; as a list of configuration parameters or a list of groups.  A list of parameters, which are not part of
any group, looks like this:</para>

<programlisting>&lt;configurationParameters&gt;
  &lt;configurationParameter&gt;
    &lt;name&gt;[String]&lt;/name&gt; 
    &lt;description&gt;[String]&lt;/description&gt; 
    &lt;type&gt;String|Integer|Float|Boolean&lt;/type&gt; 
    &lt;multiValued&gt;true|false&lt;/multiValued&gt; 
    &lt;mandatory&gt;true|false&lt;/mandatory&gt;
    &lt;overrides&gt;
      &lt;parameter&gt;[String]&lt;/parameter&gt;
      &lt;parameter&gt;[String]&lt;/parameter&gt;
        ...
    &lt;/overrides&gt;
  &lt;/configurationParameter&gt;
  &lt;configurationParameter&gt;
    ...
  &lt;/configurationParameter&gt;
    ...
&lt;/configurationParameters&gt;</programlisting>

<para>For each configuration parameter, the following are
specified:</para>

<itemizedlist><listitem><b>name</b> &ndash; the name by which
the annotator code refers to the parameter.  All parameters declared in an analysis engine descriptor must have
distinct names.  (required).  The name is composed of normal Java
identifier characters.</listitem>


<listitem><b>description</b> &ndash; a natural
language description of the intent of the parameter (optional)</listitem>


<listitem><b>type</b> &ndash; the data type of the
parameter&apos;s value &ndash; must be one of <literal>String</literal>, <literal>Integer</literal>, <literal>Float</literal>, or <literal>Boolean</literal> (required).</listitem>


<listitem><b>multiValued</b> &ndash; <literal>true</literal> if the parameter can take multiple-values (an array),
<literal>false</literal> if the parameter takes only a single value
(optional, defaults to false).</listitem>


<listitem><b>mandatory</b> &ndash; <literal>true</literal> if a value must be provided for the parameter
(optional, defaults to false).</listitem>


<listitem><b>overrides</b> &ndash;  this is used only in aggregate Analysis
Engines, but is included here for completeness.  See <b><a class="crossrefText" href="Component_Descriptor_Reference.htm#_crossRef143">Configuration
Parameter Overrides</a></b> for a discussion of configuration parameter
overriding in aggregate Analysis Engines. (optional)
</listitem></itemizedlist>

<para>A list of groups looks like this:</para>

<programlisting>&lt;configurationParameters defaultGroup=<quote>[String]</quote>
    searchStrategy=<quote>none|default_fallback|language_fallback</quote> &gt;</programlisting>

<programlisting>  &lt;commonParameters&gt;
    [zero or more parameters]
  &lt;/commonParameters&gt;</programlisting>

<programlisting>  &lt;configurationGroup names=<quote>name1 name2 name3 ...</quote>&gt;
    [zero or more parameters]
  &lt;/configurationGroup&gt;</programlisting>

<programlisting>  &lt;configurationGroup names=<quote>name4 name5 ...</quote>&gt;
    [zero or more parameters]
  &lt;/configurationGroup&gt;</programlisting>

<programlisting>  ...</programlisting>

<programlisting>&lt;/configurationParameters&gt;</programlisting>

<para>Both the<literal> &lt;commonParameters&gt;</literal> and <literal>&lt;configurationGroup&gt;</literal>
elements contain zero or more <literal>&lt;configurationParameter&gt;</literal> elements, with the same
syntax described above.</para>

<para>The <literal>&lt;com</literal><literal>monParameters&gt;</literal> element declares parameters that exist
in all groups.  Each <literal>&lt;configurationGroup&gt;</literal>
element has a names attribute, which contains a list of group names separated
by whitespace (space or tab characters).  Names consist of any number of non-whitespace characters; however the
Component Description Editor tool restricts this to be normal Java identifiers,
including the period (.) and the dash (-).  One configuration group will be created for each name, and all of the
groups will contain the same set of parameters.</para>

<para>The <literal>defaultGroup</literal> attribute specifies the name of the group to
be used in the case where an annotator does a lookup for a configuration
parameter without specifying a group name.  It may also be used as a fallback if the annotator specifies a group
that does not exist &ndash; see below.</para>

<para>The <literal>searchStrategy</literal> attribute determines the action to be
taken when the context is queried for the value of a parameter belonging to a
particular configuration group, if that group does not exist or does not
contain a value for the requested parameter.  There are currently three possible values:</para>

<itemizedlist><listitem><b>none</b><literal> </literal>&ndash;<literal> </literal>there is no fallback; return
null if there is no value in the exact group specified by the user.</listitem>


<listitem><b>default_fallback</b><literal> </literal>&ndash;<literal> </literal>if there is no value found
in the specified group, look in the default group (as defined by the <literal>default</literal> attribute)</listitem>


<listitem><b>language_fallback</b><literal> </literal>&ndash;<literal> </literal>this setting allows for a
specific use of configuration parameter groups where the groups names
correspond to ISO language and country codes (for an example, see below).  The fallback sequence is:  <literal>&lt;lang&gt;_&lt;country&gt;_&lt;region&gt; -&gt;
&lt;lang&gt;_&lt;country&gt; -&gt; &lt;lang&gt; -&gt; &lt;default&gt;.</literal>
</listitem></itemizedlist>

<h4>Example</h4>

<programlisting>&lt;configurationParameters defaultGroup=<quote>en</quote>
        searchStrategy=<quote>language_fallback</quote>&gt;</programlisting>

<programlisting>  &lt;commonParameters&gt;
    &lt;configurationParameter&gt;
      &lt;name&gt;DictionaryFile&lt;/name&gt;
      &lt;description&gt;Location of dictionary for this
           language&lt;/description&gt;
      &lt;type&gt;String&lt;/type&gt;
      &lt;multiValued&gt;false&lt;/multiValued&gt;
      &lt;mandatory&gt;false&lt;/mandatory&gt;
    &lt;/configurationParameter&gt;
  &lt;/commonParameters&gt;

  &lt;configurationGroup names=<quote>en de en-US</quote>/&gt;

  &lt;configurationGroup names=<quote>zh</quote>&gt;
    &lt;configurationParameter&gt;
      &lt;name&gt;DBC_Strategy&lt;/name&gt;
      &lt;description&gt;Strategy for dealing with double-byte
          characters.&lt;/description&gt;
      &lt;type&gt;String&lt;/type&gt;
      &lt;multiValued&gt;false&lt;/multiValued&gt;
      &lt;mandatory&gt;false&lt;/mandatory&gt;
    &lt;/configurationParameter&gt;
  &lt;/configurationGroup&gt;

&lt;/configurationParameters&gt;</programlisting>

<para>In this example, we are declaring a <literal>DictionaryFile</literal> parameter
that can have a different value for each of the languages that our TAE supports
&ndash; English (general), German, U.S. English, and Chinese.  For Chinese only, we also declare a <literal>DBC_Strategy</literal>
parameter.</para>

<para>We are using the <literal>language_fallback</literal> search
strategy, so if an annotator requests the dictionary file for the <literal>en-GB</literal>
(British English) group, we will fall back to the more general <literal>en</literal>
group.</para>

<para>Since we have defined <literal>en</literal> as the default group,
this value will be returned if the context is queried for the <literal>DictionaryFile</literal>
parameter without specifying any group name, or if a nonexistent group name is
specified.</para>

<h4><a id="_crossRef130"><emphasis>Configuration Parameter
Settings</emphasis></a></h4>

<para>If no configuration groups were declared, the <literal>&lt;configurationParameterSettings&gt;</literal>
element looks like this:</para>

<programlisting>&lt;configurationParameterSettings&gt;
  &lt;nameValuePair&gt;
    &lt;name&gt;[String]&lt;/name&gt; 
    &lt;value&gt;
      &lt;string&gt;[String]&lt;/string&gt;  | 
      &lt;integer&gt;[Integer]&lt;/integer&gt; |
      &lt;float&gt;[Float]&lt;/float&gt; |
      &lt;boolean&gt;true|false&lt;/boolean&gt;  |
      &lt;array&gt; ... &lt;/array&gt;
    &lt;/value&gt;
  &lt;/nameValuePair&gt;

  &lt;nameValuePair&gt;
    ...
  &lt;/nameValuePair&gt;

  ...
&lt;/configurationParameterSettings&gt;</programlisting>

<para>There are zero or more <literal>nameValuePair</literal> elements.  Each <literal>nameValuePair</literal> contains a
name (which refers to one of the configuration parameters) and a value for that
parameter.</para>

<para>The <literal>value</literal> element contains an element that matches the type
of the parameter.  For single-valued
parameters, this is either <literal>&lt;string&gt;</literal>, <literal>&lt;integer&gt;</literal>, <literal>&lt;float&gt;</literal>,
or <literal>&lt;boolean&gt;</literal>.  For multi-valued parameters, this is an <literal>&lt;array&gt;</literal>
element, which then contains zero or more instances of the appropriate type of
primitive value, e.g.:</para>

<programlisting>&lt;array&gt;&lt;string&gt;One&lt;/string&gt;&lt;string&gt;Two&lt;/string&gt;&lt;/array&gt;</programlisting>

<para>If configuration groups were declared, then the <literal>&lt;configurationParameterSettings&gt;</literal>
element looks like this:</para>

<programlisting>&lt;configurationParameterSettings&gt;</programlisting>

<programlisting>  &lt;settingsForGroup name=<quote>[String]</quote>&gt;
    [one or more &lt;nameValuePair&gt; elements]
  &lt;/settingsForGroup&gt;</programlisting>

<programlisting>  &lt;settingsForGroup name=<quote>[String]</quote>&gt;
    [one or more &lt;nameValuePair&gt; elements]
  &lt;/settingsForGroup&gt;</programlisting>

<programlisting>...</programlisting>

<programlisting>&lt;/configurationParameterSettings&gt;</programlisting>

<para>where each <literal>&lt;settingsForGroup&gt;</literal> element has a name that matches
one of the configuration groups declared under the <literal>&lt;configurationParameters&gt;</literal>
element and contains the parameter settings for that group.</para>

<h4><emphasis>Example</emphasis></h4>

<para>Here are the settings that correspond to the parameter
declarations in the previous example:</para>

<programlisting>&lt;configurationParameterSettings&gt;</programlisting>

<programlisting>  &lt;settingsForGroup name=<quote>en</quote>&gt;
    &lt;nameValuePair&gt;
      &lt;name&gt;DictionaryFile&lt;/name&gt;
      &lt;value&gt;&lt;string&gt;resourcesEnglishdictionary.dat&gt;&lt;/string&gt;&lt;/value&gt;
    &lt;/nameValuePair&gt;
  &lt;/settingsForGroup&gt;     </programlisting>

<programlisting>  &lt;settingsForGroup name=<quote>en-US</quote>&gt;
    &lt;nameValuePair&gt;
      &lt;name&gt;DictionaryFile&lt;/name&gt;
      &lt;value&gt;&lt;string&gt;resourcesEnglish_USdictionary.dat&lt;/string&gt;&lt;/value&gt;
    &lt;/nameValuePair&gt;
  &lt;/settingsForGroup&gt;</programlisting>

<programlisting>  &lt;settingsForGroup name=<quote>de</quote>&gt;
    &lt;nameValuePair&gt;
      &lt;name&gt;DictionaryFile&lt;/name&gt;
      &lt;value&gt;&lt;string&gt;resourcesDeutschdictionary.dat&lt;/string&gt;&lt;/value&gt;
    &lt;/nameValuePair&gt;
  &lt;/settingsForGroup&gt;</programlisting>

<programlisting>  &lt;settingsForGroup name=<quote>zh</quote>&gt;
    &lt;nameValuePair&gt;
      &lt;name&gt;DictionaryFile&lt;/name&gt;
      &lt;value&gt;&lt;string&gt;resourcesChinesedictionary.dat&lt;/string&gt;&lt;/value&gt;
    &lt;/nameValuePair&gt;</programlisting>

<programlisting>    &lt;nameValuePair&gt;
      &lt;name&gt;DBC_Strategy&lt;/name&gt;
      &lt;value&gt;&lt;string&gt;default&lt;/string&gt;&lt;/value&gt;
    &lt;/nameValuePair&gt;</programlisting>

<programlisting>  &lt;/settingsForGroup&gt;</programlisting>

<programlisting>&lt;/configurationParameterSettings&gt;</programlisting>

<programlisting></programlisting>

<h4><a id="_crossRef131">Type System Definition</a></h4>

<programlisting>&lt;typeSystemDescription&gt;</programlisting>

<programlisting>  &lt;name&gt; [String] &lt;/name&gt;
  &lt;description&gt;[String]&lt;/description&gt;
  &lt;version&gt;[String]&lt;/version&gt;
  &lt;vendor&gt;[String]&lt;/vendor&gt; </programlisting>

<programlisting>  &lt;imports&gt;
    &lt;import ...&gt;
    ...
  &lt;/imports&gt; </programlisting>

<programlisting>  &lt;types&gt;
    &lt;typeDescription&gt;
      ...
    &lt;/typeDescription&gt;</programlisting>

<programlisting>    ...</programlisting>

<programlisting>  &lt;/types&gt;</programlisting>

<programlisting>&lt;/typeSystemDescription&gt;</programlisting>

<para>A <literal>typeSystemDescription</literal> element defines a type system for
an Analysis Engine.  The syntax for the
element is described in section <a class="crossrefText" href="Component_Descriptor_Reference.htm#_crossRef123">23.3
</a> of this
chapter.</para>

<para>The recommended usage is to <literal>import</literal> an external type
system, using the import syntax described in section <a class="crossrefText" href="Component_Descriptor_Reference.htm#_crossRef121">23.1 </a> of this chapter.  For example:</para>

<programlisting>&lt;typeSystemDescription&gt;
  &lt;imports&gt;
    &lt;import location=<quote>MySharedTypeSystem.xml</quote>&gt;
  &lt;/imports&gt;
&lt;/typeSystemDescription&gt;</programlisting>

<para>This allows several AEs to share a single type system
definition.  The file <literal>MySharedTypeSystem.xml</literal>
would then contain the full type system information, including the <literal>name</literal>, <literal>description</literal>, <literal>vendor</literal>, <literal>version</literal>, and <literal>types</literal>.</para>

<h4><a id="_crossRef132">Type
Priority Definition</a></h4>

<programlisting>&lt;typePriorities&gt;
  &lt;name&gt; [String] &lt;/name&gt;
  &lt;description&gt;[String]&lt;/description&gt;
  &lt;version&gt;[String]&lt;/version&gt;
  &lt;vendor&gt;[String]&lt;/vendor&gt;</programlisting>

<programlisting>  &lt;imports&gt;
    &lt;import ...&gt;
    ...
  &lt;/imports&gt; </programlisting>

<programlisting>  &lt;priorityLists&gt;
    &lt;priorityList&gt;
      &lt;type&gt;[TypeName]&lt;/type&gt;
      &lt;type&gt;[TypeName]&lt;/type&gt;
        ...
    &lt;/priorityList&gt;</programlisting>

<programlisting>    ...</programlisting>

<programlisting>  &lt;/priorityLists&gt;
&lt;/typePriorities&gt;</programlisting>

<para>The <literal>&lt;typePriorities&gt;</literal> element contains zero or more <literal>&lt;priorityList&gt;</literal> elements; each <literal>&lt;priorityList&gt;</literal> contains zero or more types.  Like a type system, a type priorities definition
may also declare a name, description, version, and vendor, and may import other
type priorities.  The import syntax is
described in section <a class="crossrefText" href="Component_Descriptor_Reference.htm#_crossRef121">23.1
</a> of this chapter.</para>

<para>Type priority is
used when iterating over feature structures in the CAS.  For example, if the CAS contains a <literal>Sentence</literal> annotation and a <literal>Paragraph</literal>
annotation with the same span of text (i.e. a one-sentence paragraph), which
annotation should be returned first by an iterator?  Probably the Paragraph, since it is
conceptually <quote>bigger,</quote> but the framework does not know that and must
be explicitly told that the Paragraph annotation has priority over the Sentence
annotation, like this:</para>

<programlisting>&lt;typePriorities&gt;
  &lt;priorityList&gt;
    &lt;type&gt;org.myorg.Paragraph&lt;/type&gt;
    &lt;type&gt;org.myorg.Sentence&lt;/type&gt;
  &lt;/priorityList&gt;
&lt;/typePriorities&gt;</programlisting>

<para>All of the <literal>&lt;priorityList&gt;</literal> elements defined in the descriptor
(and in all component descriptors of an aggregate analysis engine descriptor)
are merged to produce a single priority list.</para>

<para>Subtypes of types
specified here are also ordered, unless overridden by another user-specified
type ordering.  For example, if you
specify type A comes before type B, then subtypes of A will come before
subtypes of B, unless there is an overriding specification which declares some
subtype of B comes before some subtype of A.</para>

<para>If there are
inconsistencies between the priority list (type A declared before type B in one
priority list, and type B declared before type A in another), the framework
will throw an exception.</para>

<para>User defined
indexes may declare if they wish to use the type priority or not; see the next
section.</para>

<h4><a id="_crossRef133">Index Definition</a></h4>

<programlisting>&lt;fsIndexCollection&gt;</programlisting>

<programlisting>  &lt;name&gt;[String]&lt;/name&gt;
  &lt;description&gt;[String]&lt;/description&gt;
  &lt;version&gt;[String]&lt;/version&gt;
  &lt;vendor&gt;[String]&lt;/vendor&gt; </programlisting>

<programlisting>  &lt;imports&gt;
    &lt;import ...&gt;
    ...
  &lt;/imports&gt;</programlisting>

<programlisting>  &lt;fsIndexes&gt; </programlisting>

<programlisting>    &lt;fsIndexDescription&gt;
      ...
    &lt;/fsIndexDescription&gt;</programlisting>

<programlisting>    &lt;fsIndexDescription&gt;
      ...
    &lt;/fsIndexDescription&gt;</programlisting>

<programlisting>  &lt;/fsIndexes&gt;</programlisting>

<programlisting>&lt;/fsIndexCollection&gt;</programlisting>

<para>The <literal>fsIndexCollection</literal> element declares<emphasis> Feature Structure
Indexes</emphasis>, which define an index that holds feature structures of a given
type.  Information in the CAS is always
accessed through an index.  There is a built-in
default annotation index declared which can be used to access instances of type
Annotation (or its subtypes), but if there is a need for a specialized index it
must be declared in this element.  See <a class="crossrefText" href="CAS_Reference.htm#_crossRef77">Chapter
26, <b>CAS Reference</b></a> for details on FS indexes.</para>

<para>Like type systems and type priorities, an <literal>fsIndexCollection</literal>
can declare a <literal>name</literal>,
<literal>description</literal>,
<literal>vendor</literal>,
and <literal>version</literal>,
and may import other <literal>fsIndexCollection</literal>s. The import syntax is described in
section <a class="crossrefText" href="Component_Descriptor_Reference.htm#_crossRef121">23.1
</a> of this chapter.</para>

<para>An <literal>fsIndexCollection</literal> may also define zero or more <literal>fsIndexDescr</literal><literal>iption</literal>
elements, each of which defines a single index.  Each <literal>fsIndexDescription</literal>
has the form:</para>

<programlisting>&lt;fsIndexDescription&gt;</programlisting>

<programlisting>  &lt;label&gt;[String]&lt;/label&gt;
  &lt;typeName&gt;[TypeName]&lt;/typeName&gt;
  &lt;kind&gt;sorted|bag|set&lt;/kind&gt;</programlisting>

<programlisting>  &lt;keys&gt;</programlisting>

<programlisting>    &lt;fsIndexKey&gt;
      &lt;featureName&gt;[Name]&lt;/featureName&gt;
      &lt;comparator&gt;standard|reverse&lt;/comparator&gt;
    &lt;/fsIndexKey&gt;</programlisting>

<programlisting>    &lt;fsIndexKey&gt;
      &lt;typePriority/&gt;
    &lt;/fsIndexKey&gt;</programlisting>

<programlisting>    ...</programlisting>

<programlisting>  &lt;/keys&gt;
&lt;/fsIndexDescription&gt;</programlisting>

<para>The <literal>label</literal> element defines the name by which applications and
annotators refer to this index.  The <literal>typeName</literal>
element contains the name of the type that will be contained in this
index.  This must match one of the type
names defined in the <literal>&lt;typeSystemDescription&gt;</literal>.</para>

<para>There are three possible values for the <literal>&lt;kind&gt;</literal>
of index.  Sorted indexes enforce an
ordering of feature structures, and may contain duplicates.  Bag indexes do not enforce ordering, and also
may contain duplicates.  Set indexes do
not enforce ordering and may not contain duplicates.  If the <literal>&lt;kind&gt;</literal>element is
omitted, it will default to sorted, which is the most common type of index.</para>

<para>An index may define one or more <emphasis>keys</emphasis>.  These keys determine the sort order of the
feature structures within a sorted index, and determine equality for set
indexes.  Bag indexes do not use keys.  Keys are ordered by precedence &ndash;  the first key is evaluated first, and
subsequent keys are evaluated only if necessary.</para>

<para>Each key is represented by an <literal>fsIndexKey</literal> element.  Most <literal>fsIndexKeys</literal> contains a <literal>featureName</literal>
and a <literal>comparator</literal>.  The <literal>featureName</literal> must match the
name of one of the features for the type specified in the <literal>&lt;typeName&gt;</literal> element
for this index.  The comparator defines
how the features will be compared &ndash; a value of <literal>standard</literal> means that
features will be compared using the standard comparison for their data type
(e.g. for numerical types, smaller values precede larger values, and for string
types, Unicode string comparison is performed).  A value of <literal>reverse</literal> means that features will be compared using the
reverse of the standard comparison (e.g. for numerical types, larger values
precede smaller values, etc.).  For Set
indexes, the comparator direction is ignored &ndash; the keys are only used for the
equality testing.</para>

<para>Each key used in comparisons must refer to a feature whose
range type is String, Float, or Integer.</para>

<para>There is a second type of a key, one which contains only
the <literal>&lt;typePriority/&gt;</literal>.  When this key is used, it indicates that
Feature Structures will be compared using the type priorities declared in the <literal>&lt;typePriorities&gt;</literal>
section of the descriptor.</para>

<h4><a id="_crossRef134">Capabilities</a></h4>

<programlisting>&lt;capabilities&gt;
  &lt;capability&gt;</programlisting>

<programlisting>    &lt;inputs&gt;
      &lt;type allAnnotatorFeatures=<quote>true|false</quote>&gt;[TypeName]&lt;/type&gt;
      ...
      &lt;feature&gt;[TypeName]:[Name]&lt;/feature&gt;
      ...
    &lt;/inputs&gt;</programlisting>

<programlisting>    &lt;outputs&gt;
      &lt;type allAnnotatorFeatures=<quote>true|false</quote>&gt;[TypeName]&lt;/type&gt;
      ...
      &lt;feature&gt;[TypeName]:[Name]&lt;/feature&gt;
      ...
    &lt;/output&gt;</programlisting>

<programlisting>    &lt;languagesSupported&gt;
      &lt;language&gt;[ISO Language ID]&lt;/language&gt;
        ...
    &lt;/languagesSupported&gt;</programlisting>

<programlisting>    &lt;inputSofas&gt;
      &lt;sofaName&gt;[name]&lt;/sofaName&gt;
      ...
    &lt;/inputSofas&gt;</programlisting>

<programlisting>    &lt;outputSofas&gt;
      &lt;sofaName&gt;[name]&lt;/sofaName&gt;
      ...
    &lt;/outputSofas&gt;
  &lt;/capability&gt;</programlisting>

<programlisting>  &lt;capability&gt;
    ...
  &lt;/capability&gt;</programlisting>

<programlisting>  ...</programlisting>

<programlisting>&lt;/capabilities&gt;</programlisting>

<para>The capabilities definition is used by the UIMA Framework
in several ways, including setting up the Results Specification for process
calls, routing control for aggregates based on language, and as part of the
Sofa mapping function.</para>

<para>The <literal>capabilities</literal> element contains one or more <literal>capability</literal>
elements.  Because you can therefore
declare multiple capability sets, you can use this to model component behavior
that for a given set of inputs, produces a particular set of outputs.</para>

<para>Each <literal>capability</literal> contains <literal>inputs</literal>, <literal>outputs</literal>,
<literal>languagesSupported,
inputSofas, and outputSofas</literal>.  Inputs and outputs element are required (though they may be empty); <literal>&lt;languagesSupported&gt;,</literal> <literal>&lt;inputSofas</literal>&gt;,
and <literal>&lt;outputSofas&gt;</literal> are optional and is used
only used for TAEs.</para>

<para>Both inputs and outputs may contain a mixture of type and
feature elements.</para>

<para><literal>&lt;type...&gt;</literal> elements contain the name of one of the
types defined in the type system or one of the built in types.  Declaring a type as an input means that this
component expects instances of this type to be in the CAS when it receives it
to process.  Declaring a type as an
output means that this component creates new instances of this type in the CAS.</para>

<para>There is an optional attribute <literal>allAnnotatorFeatures</literal>,
which defaults to false if omitted.  The
Component Descriptor Editor tool defaults this to true when a new type is added
to the list of inputs and/or outputs.  When this attribute is true, it specifies that all of the type&apos;s
features are also declared as input or output.  Otherwise, the features that are required as inputs or populated as
outputs must be explicitly specified in feature elements.</para>

<para><literal>&lt;feature...&gt;</literal> elements contain the <quote>fully-qualified</quote>
feature name, which is the type name followed by a colon, followed by the
feature name, e.g. <literal>org.myorg.tae.TokenAnnotation:lemma</literal>.  <literal>&lt;feature...&gt;</literal> elements in the <literal>&lt;</literal><literal>inputs&gt;</literal>
section must also have a corresponding type declared as an input.  In output sections, this is not required.  If the type is not specified as an output,
but a feature for that type is, this means that existing instances of the type
have the values of the specified features updated.  Any type mentioned in a <literal>&lt;feature&gt;</literal>
element must be either specified as an input or an output or both.</para>

<para><literal>language </literal>elements contain one of the ISO language
identifiers, such as <literal>en</literal> for English, or<literal> </literal><literal>en-US</literal>
for the United States
dialect of English.</para>

<para>The list of language codes can be found here:</para>

<programlisting><emphasis><a href="http://www.ics.uci.edu/pub/ietf/http/related/iso639.txt">http://www.ics.uci.edu/pub/ietf/http/related/iso639.txt</a></emphasis></programlisting>

<para>and the country codes here:</para>

<programlisting><emphasis><a href="http://www.chemie.fu-berlin.de/diverse/doc/ISO_3166.html">http://www.chemie.fu-berlin.de/diverse/doc/ISO_3166.html</a></emphasis></programlisting>

<para><literal>&lt;inputSofas&gt;</literal> and <literal>&lt;outputSofas&gt;</literal> declare sofa names used by this
component.  All Sofa names must be unique
within a particular capability set.  A
Sofa name must be an input or an output, and cannot be both.  It is an error to have a Sofa name declared
as an input in one capability set, and also have it declared as an output in
another capability set.</para>

<para>A <literal>&lt;sofaName&gt;</literal> is written
as a simple Java-style identifier, without any periods in the name, except that
it may be written to end in    .*    .  If
written in this manner, it specifies a set of Sofa names, all of which start
with the base name (the part before the .*) followed by a period and then an
arbitrary Java identifier (without periods).  This form is used to specify in the descriptor that the component could
generate an arbitrary number of Sofas, the exact names and numbers of which are
unknown before the component is run.</para>

<h4>OperationalProperties</h4>

<para>Components can specify specific operational properties
that can be useful in deployment.  The
following are available:</para>

<para><literal>&lt;operationalProperties&gt;<br/>
  &lt;modifiesCas&gt;</literal><literal> true|false
&lt;/modifiesCas&gt;<br/>
  &lt;multipleDeploymentAllowed&gt;</literal><literal> true|false
&lt;/multipleDeploymentAllowed&gt;<br/>
  &lt;</literal> <literal>outputsNewCASes&gt;
true|false &lt;/outputsNewCASes&gt;<br/>
&lt;/operationalProperties&gt;</literal></para>

<para><literal>ModifiesCas</literal>, if false,
indicates that this component does not modify the CAS.  If it is not specified, the default value is
true except for CAS Consumer components.</para>

<note>If you wrap one or more CAS
Consumers inside an aggregate as the only components, you must explicitly
specify in the aggregate the ModifiesCas property as false (assuming the CAS
Consumer components take the default here); otherwise the framework will
complain about inconsistent settings for these.
</listitem></itemizedlist>

<para><literal>multipleDeploymentAllowed</literal>, if
true, allows the component to be deployed multiple times to increase performance
throught scale-out techniques.  If it is
not specified, the default value is true, except for CAS Consumer and
Collection Reader components.</para>

<para><literal>outputsNewCASes, </literal>if true,
allows the  component to create new CASes
during processing, for example to break a large artifact into smaller
pieces.  See <b><a class="crossrefText" href="Segmenter_Developers_Guide.htm#_crossRef273">CAS Multiplier
Developer&apos;s Guide</a></b> <a class="crossrefPage" href="Segmenter_Developers_Guide.htm#_crossRef273"></a> for details<literal>.</literal></para>

<h4><a id="_crossRef135">External
Resource Dependencies</a></h4>

<programlisting>&lt;externalResourceDependencies&gt;
  &lt;externalResourceDependency&gt;
    &lt;key&gt;[String]&lt;/key&gt;
    &lt;description&gt;[String] &lt;/description&gt;
    &lt;interfaceName&gt;[String]&lt;/interfaceName&gt;
    &lt;optional&gt;true|false&lt;/optional&gt;
  &lt;/externalResourceDependency&gt;</programlisting>

<programlisting>  &lt;externalResourceDependency&gt;
    ...
  &lt;/externalResourceDependency&gt;</programlisting>

<programlisting>  ...</programlisting>

<programlisting>&lt;/externalResourceDependencies&gt;</programlisting>

<para>A primitive annotator may declare zero or more <literal>&lt;externalResourceDependency&gt;</literal>
elements.  Each dependency has the
following elements:</para>

<itemizedlist><listitem><literal>key</literal> &ndash; the string by which
the annotator code will attempt to access the resource.  Must be unique within this annotator.</listitem>


<listitem><literal>description</literal> &ndash; a textual description
of the dependency</listitem>


<listitem><literal>interfaceName</literal> &ndash; the
fully-qualified name of the Java interface through which the annotator will
access the data.  This is optional.  If not specified, the annotator can only get
an InputStream to the data.</listitem>


<listitem><literal>optional</literal> &ndash; whether the
resource is optional.  If false, an
exception will be thrown if no resource is assigned to satisfy this
dependency.  Defaults to false.
</listitem></itemizedlist>

<h4><a id="_crossRef136">Resource Manager Configuration</a></h4>

<programlisting>&lt;resourceManagerConfiguration&gt;</programlisting>

<programlisting>  &lt;name&gt;[String]&lt;/name&gt;
  &lt;description&gt;[String]&lt;/description&gt;
  &lt;version&gt;[String]&lt;/version&gt;
  &lt;vendor&gt;[String]&lt;/vendor&gt; </programlisting>

<programlisting>  &lt;imports&gt;
    &lt;import ...&gt;
    ...
  &lt;/imports&gt;</programlisting>

<programlisting>  &lt;externalResources&gt;</programlisting>

<programlisting>    &lt;externalResource&gt;
      &lt;name&gt;[String]&lt;/name&gt;
      &lt;description&gt;[String]&lt;/description&gt;
      &lt;fileResourceSpecifier&gt;
        &lt;fileUrl&gt;[URL]&lt;/fileUrl&gt;
      &lt;/fileResourceSpecifier&gt;
      &lt;implementationName&gt;[String]&lt;/implementationName&gt;
    &lt;/externalResource&gt;
    ...
  &lt;/externalResources&gt;</programlisting>

<programlisting>  &lt;externalResourceBindings&gt;
    &lt;externalResourceBinding&gt;
      &lt;key&gt;[String]&lt;/key&gt;
      &lt;resourceName&gt;[String]&lt;/resourceName&gt;
    &lt;/externalResourceBinding&gt;
    ...
  &lt;/externalResourceBindings&gt;</programlisting>

<programlisting>&lt;/resourceManagerConfiguration&gt;</programlisting>

<para>This element declares external resources and binds them to
annotators&apos; external resource dependencies.</para>

<para>The <literal>resourceManagerConfiguration</literal> element may optionally
contain an <literal>import</literal>,
which allows resource definitions to be stored in a separate (shareable) file.
See section <a class="crossrefText" href="Component_Descriptor_Reference.htm#_crossRef122">23.2
</a> for details.</para>

<para>The <literal>externalResources</literal> element contains zero or more <literal>externalResource</literal>
elements, each of which consists of:</para>

<itemizedlist><listitem><literal>name</literal> &ndash; the name of the
resource.  This name is referred to in
the bindings (see below).  Resource names
need to be unique within any Aggregate Analysis Engine or Collection Processing
Engine, so the Java-like <literal>org.myorg.mycomponent.MyResource</literal> syntax is recommended.</listitem>


<listitem><literal>description</literal> &ndash; English
description of the resource</listitem>


<listitem><literal>resource specifier </literal>&ndash;
Declares the location of the resource.  There are different possibilities for how this is done (see below).</listitem>


<listitem><literal>implementationName</literal> &ndash; The
fully-qualified name of the Java class that will be instantiated from the
resource data.  This is optional; if not
specified, the resource will be accessible as an input stream to the raw data.  If specified, the Java class must implement
the <literal>interfaceName</literal> that is specified in the
External Resource Dependency to which it is bound.
</listitem></itemizedlist>

<para>One possibility for the resource specifier is a <literal>&lt;fileResourceSpecifier&gt;</literal>,
as shown above.  This simply declares a
URL to the resource data.  This support
is built on the Java class URL and its method URL.openStream(); it supports the
protocols <quote>file</quote>, <quote>http</quote> and <quote>jar</quote> (for referring
to files in jars) by default, and you can plug in handlers for other protocols.
  The URL has to start with file: (or
some other protocol).  It is relative to
either the classpath or the <quote>data path</quote>.  The data path works like the classpath but
can be set programmatically via <literal>ResourceManager.setDataPath()</literal>.  Setting the Java System property <literal>uima.datapath</literal> also works.</para>

<para><literal>file:com/ibm.d.txt</literal> is a
relative path; relative paths for resources are resolved using the classpath
and / or the datapath.  For the file
protocol, URLs starting with file:/ or file:/// are absolute.  Note that <literal>file://org/apache/d.txt</literal>
is NOT an absolute path starting with com.  The &apos;//&apos; indicates that what follows is a host name.  Therefore if you try to use this URL it will
complain that it can&apos;t connect to the host <quote>com</quote></para>

<para>Another option is a <literal>&lt;fileLanguag</literal><literal>eResourceSpecifier&gt;</literal>,
which is intended to support resources, such as dictionaries, that depend on
the language of the document being processed.  Instead of a single URL, a prefix and suffix are specified, like this:</para>

<programlisting>&lt;fileLanguageResourceSpecifier&gt;
  &lt;fileUrlPrefix&gt;file:FileLanguageResource_implTest_data_&lt;/fileUrlPrefix&gt;
  &lt;fileUrlSuffix&gt;.dat&lt;/fileUrlSuffix&gt;
&lt;/fileLanguageResourceSpecifier&gt;</programlisting>

<para>The URL of the actual resource is then formed by
concatenating the prefix, the language of the document (as an ISO language
code, e.g. <literal>en</literal>
or <literal>en-US</literal>
&ndash; see <b><a class="crossrefText" href="Component_Descriptor_Reference.htm#_crossRef134">Capabilities</a></b> for more information), and the suffix.</para>

<para>The <literal>externalResourceBindings</literal> element declares which resources
are bound to which dependencies.  Each <literal>externalResourceBinding</literal>
consists of:</para>

<itemizedlist><listitem><literal>key</literal> &ndash; identifies the
dependency.  For a binding declared in a
primitive analysis engine descriptor, this must match the value of the <literal>key</literal> element of one of the <literal>externalResourceDependency</literal>
elements.  Bindings may also be specified
in aggregate analysis engine descriptors, in which case a compound key is used
&ndash; see section<emphasis> <b><a class="crossrefText" href="Component_Descriptor_Reference.htm#_crossRef144">External
Resource Bindings</a></b></emphasis>.</listitem>


<listitem><literal>resourceName</literal> &ndash; the name of
the resource satisfying the dependency.  This must match the value of the <literal>name</literal>
element of one of the <literal>externalResource</literal> declarations.
</listitem></itemizedlist>

<para>A given resource dependency may only be bound to one
external resource; one external resource may be bound to many dependencies &ndash; to
allow resource sharing.</para>

<h4><a id="_crossRef137">Environment Variable References</a></h4>

<para>In several places throughout the descriptor, it is
possible to reference environment variables.  In Java, these are actually references to Java system properties.  To reference system environment variables
from a Java analysis engine you must pass the environment variables into the
Java virtual machine by using the <literal>-D</literal> option on the <literal>java</literal> command line.</para>

<para>The syntax for environment variable references is <literal>&lt;envVarRef&gt;[VariableName]&lt;/envVarRef&gt;</literal>,
where [VariableName] is any valid Java system property name.  Environment variable references are valid in
the following places:</para>

<itemizedlist spacing="compact"><listitem>The value of a configuration
parameter (String-valued parameters only)</listitem>


<listitem>The <literal>&lt;annotatorImplementationName&gt;</literal>
element of a primitive TAE descriptor</listitem>


<listitem>The <literal>&lt;name&gt;</literal> element
within <literal>&lt;analysisEngineMetaData&gt;</literal></listitem>


<listitem>Within a <literal>&lt;fileResourceSp</literal><literal>ecifier&gt;</literal>
or <literal>&lt;fileLanguageResourceSpecifier&gt;</literal>
</listitem></itemizedlist>

<para>For example, if the value of a configuration parameter
were specified as: <literal>&lt;string&gt;&lt;envVarRef&gt;TEMP_DIR&lt;/envVarRef&gt;/temp.dat&lt;/string&gt;</literal>,
and the value of the <literal>TEMP_DIR</literal> Java System property were <literal>c:/temp</literal>, then the
configuration parameter&apos;s value would evaluate to <literal>c:/temp/temp.dat</literal>.</para>

<h3><a id="_crossRef138">Aggregate Analysis Engine
Descriptors</a></h3>

<para>Aggregate Analysis Engines do not contain an annotator,
but instead contain one or more component (also called <emphasis>delegate</emphasis>)
analysis engines.</para>

<para>Aggregate Analysis Engine Descriptors maintain most of the
same structure as Primitive Analysis Engine Descriptors.  The differences are:</para>

<itemizedlist><listitem>An Aggregate Analysis Engine
Descriptor contains the element <literal>&lt;primitive&gt;false&lt;/primitive&gt;</literal>
rather than <literal>&lt;primitive&gt;true&lt;/primitive&gt;</literal>.
</listitem>


<listitem>An Aggregate Analysis Engine
Descriptor must not include a <literal>&lt;annotatorImplementationName&gt;</literal>
element.</listitem>


<listitem>In place of the <literal>&lt;annotatorImplementationName&gt;</literal>,
an Aggregate Analysis Engine Descriptor must have a <literal>&lt;delegateAnalysisEngineSpecifiers&gt;</literal>
element.  See <b><a class="crossrefText" href="Component_Descriptor_Reference.htm#_crossRef139">Delegate
Analysis Engine Specifiers</a></b>.</listitem>


<listitem>An Aggregate Analysis Engine
Descriptor may provide a <literal>&lt;flowController&gt;</literal>
element immediately following the <literal>&lt;delegateAnalysisEngineSpecifiers&gt;</literal>.  See &lt;XREF: Flow Controller&gt;.</listitem>


<listitem>Under the analysisEngineMetaData
element, an Aggregate Analysis Engine Descriptor may specify an additional
element -- <literal>&lt;flowConstraints&gt;</literal>.  See <b><a class="crossrefText" href="Component_Descriptor_Reference.htm#_crossRef140">FlowConstraints</a></b>.  Typically only one of <literal>&lt;flowController&gt;</literal>
and <literal>&lt;flowConstraints&gt;</literal> are specified. If both
are specified, the <literal>&lt;flowController&gt;</literal> takes
precedence, and the flow controller implementation can use the information in
specified in the <literal>&lt;flowConstraints&gt;</literal> as part of
its configuration input.</listitem>


<listitem>An aggregate Analysis Engine
Descriptors must not contain a <literal>&lt;typeSystemDescription&gt;</literal>
element.  The Type System of the
Aggregate Analysis Engine is derived by merging the Type System of the Analysis
Engines that the aggregate contains.</listitem>


<listitem>Within aggregate Analysis Engine
Descriptors, <literal>&lt;configurationParameter&gt;</literal> elements may define <literal>&lt;overrides&gt;</literal>.  See <b><a class="crossrefText" href="Component_Descriptor_Reference.htm#_crossRef143">Configuration
Parameter Overrides</a></b>.</listitem>


<listitem>External Resource Bindings can
bind resources to dependencies declared by any delegate AE within the
aggregate.  See <b><a class="crossrefText" href="Component_Descriptor_Reference.htm#_crossRef144">External
Resource Bindings</a></b>.</listitem>


<listitem>An additional optional element, <literal>&lt;sofaMappings&gt;</literal>, may be included.
</listitem></itemizedlist>

<h4><a id="_crossRef139">Delegate
Analysis Engine Specifiers</a></h4>

<programlisting>&lt;delegateAnalysisEngineSpecifiers&gt;</programlisting>

<programlisting>  &lt;delegateAnalysisEngine key=<quote>[String]</quote>&gt;</programlisting>

<programlisting>    &lt;analysisEngineDescription&gt;...&lt;/analysisEngineDescription&gt; |
    &lt;import .../&gt; </programlisting>

<programlisting>  &lt;/delegateAnalysisEngine&gt;</programlisting>

<programlisting>  &lt;delegateAnalysisEngine key=<quote>[String]</quote>&gt;</programlisting>

<programlisting>    ...</programlisting>

<programlisting>  &lt;/delegateAnalysisEngine&gt;</programlisting>

<programlisting>  ...</programlisting>

<programlisting>&lt;/delegateAnalysisEngineSpecifiers&gt;</programlisting>

<programlisting></programlisting>

<para>The <literal>delegateAnal</literal><literal>ysisEngineSpecifiers</literal> element contains one or more <literal>delegateAnalysisEngine</literal>
elements.  Each of these must have a
unique key, and must contain either:</para>

<itemizedlist><listitem>A complete <literal>analysisEngineDescription</literal>
element describing the delegate analysis engine    <b>OR</b></listitem>


<listitem>An <literal>import</literal> element giving the
name or location of the XML descriptor for the delegate analysis engine (see
section  <a class="crossrefText" href="Component_Descriptor_Reference.htm#_crossRef121">23.1 </a>).
</listitem></itemizedlist>

<para>The latter is the much more common usage, and is the only
form supported by the Component Descriptor Editor tool.</para>

<h4>FlowController</h4>

<programlisting>  &lt;flowController key=<quote>[String]</quote>&gt;
    &lt;flowControllerDescription&gt;...&lt;/flowControllerDescription&gt; |
    &lt;import .../&gt;
  &lt;/flowController&gt;</programlisting>

<para>The optional <literal>flowController</literal>
element identifies the descriptor of the FlowController component that will be
used to determine the order in which delegate Analysis Engine are called.</para>

<para>The <literal>key</literal> attribute is optional,
but recommended; it assigns the FlowController an identifier that can be used
for configuration parameter overrides, Sofa mappings, or external resource
bindings.  The key must not be the same
as any of the delegate analysis engine keys.</para>

<para>As with the <literal>delegateAnalysisEngine</literal>
element, the <literal>flowController</literal> element may contain
either a complete <literal>flowControllerDescription</literal> or an <literal>import</literal>, but the import is recommended.  The Component Descriptor Editor tool only
supports imports here.</para>

<h4><a id="_crossRef140">FlowConstraints</a></h4>

<para>If a <literal>&lt;flowController&gt;</literal> is
not specified, the order in which delegate Analysis Engines are called within
the aggregate Analysis Engine is specified using the <literal>&lt;flowConstraints&gt;</literal>
element, which must occur immediately following the <literal>configurationParameterSettings</literal>
element.  If a <literal>&lt;flowController&gt;</literal> is
specified, then the <literal>&lt;flowConstraints&gt;</literal> are optional.  They can be used to pass an ordering of
delegate keys to the <literal>&lt;flowController&gt;</literal>.</para>

<para>There are two options for flow constraints -- <literal>&lt;fixedFlow&gt;</literal>
or <literal>&lt;capabilityLangua</literal><literal>geFlow&gt;</literal>.
Each is discussed in a separate section below.</para>

<h4><a id="_crossRef141"><emphasis>Fixed Flow</emphasis></a></h4>

<programlisting>&lt;flowConstraints&gt;</programlisting>

<programlisting>  &lt;fixedFlow&gt;
    &lt;node&gt;[String]&lt;/node&gt;
    &lt;node&gt;[String]&lt;/node&gt;
    ...
  &lt;/fixedFlow&gt;</programlisting>

<programlisting>&lt;/flowConstraints&gt;</programlisting>

<para>The <literal>flowConstraints</literal> element must be included immediately
following the <literal>configurationParameterSettings</literal>
element.</para>

<para>Currently the <literal>flowConstraints</literal> element must contain a <literal>fixedFlow</literal>
element.  Eventually, other types of flow
constraints may be possible.</para>

<para>The <literal>fixedFlow</literal> element contains one or more <literal>node</literal>
elements, each of which contains an identifier which must match the key of a
delegate analysis engine specified in the <literal>delegateAnalysisEngineSpecifiers</literal>
element.</para>

<h4><a id="_crossRef142"><emphasis>Capability Language Flow</emphasis></a></h4>

<programlisting>&lt;flowConstraints&gt;
  &lt;capabilityLanguageFlow&gt;
    &lt;node&gt;[String]&lt;/node&gt;
    &lt;node&gt;[String]&lt;/node&gt;
    ...
  &lt;/capabilityLanguageFlow&gt;
&lt;/flowConstraints&gt;</programlisting>

<para>If you use <literal>&lt;capabilityLanguageFlow&gt;</literal>, the delegate Analysis
Engines named by the <literal>&lt;node&gt;</literal> elements are called in the given order,
except that a delegate Analysis Engine is skipped if any of the following are
true (according to that Analysis Engine&apos;s declared output capabilities):</para>

<itemizedlist><listitem>It cannot produce any of the
aggregate Analysis Engine&apos;s output capabilities for the language of the current
document.</listitem>


<listitem>All of the output capabilities
have already been produced by an earlier Analysis Engine in the flow.
</listitem></itemizedlist>

<para>For example, if two annotators produce <literal>org.myorg.TokenAnnotation</literal>
feature structures for the same language, these feature structures will only be
produced by the first annotator in the list.</para>

<h4><a id="_crossRef143">Configuration
Parameter Overrides</a></h4>

<para>In an aggregate Analysis Engine Descriptor, each <literal>&lt;configurationParameter&gt;
</literal>element should contain an <literal>&lt;overrides&gt;</literal> element,
with the following syntax:</para>

<programlisting>&lt;overrides&gt;</programlisting>

<programlisting>  &lt;parameter&gt;
    [delegateAnalysisEngineKey]/[parameterName]
  &lt;/parameter&gt;</programlisting>

<programlisting>  &lt;parameter&gt;
    [delegateAnalysisEngineKey]/[parameterName]
  &lt;/parameter&gt;
  ...</programlisting>

<programlisting>&lt;/overrides&gt;</programlisting>

<para>Since aggregate Analysis Engines have no code associated
with them, the only way in which their configuration parameters can affect
their processing is by overriding the parameter values of one or more delegate
analysis engines.  The <literal>&lt;overrides&gt; </literal>element
determines which parameters, in which delegate Analysis Engines, are overridden
by this configuration parameter.</para>

<para>For example, consider an aggregate Analysis Engine
Descriptor that contains delegate Analysis Engines with keys <literal>annotator1</literal>
and <literal>annotator2</literal>
(as declared in the &lt;delegateAnalysisEngine&gt; element &ndash; see <b><a class="crossrefText" href="Component_Descriptor_Reference.htm#_crossRef139">Delegate Analysis
Engine Specifiers</a></b>) and also declares a configuration parameter
as follows:</para>

<programlisting>&lt;configurationParameter&gt;
  &lt;name&gt;AggregateParam&lt;/name&gt;
  &lt;type&gt;String&lt;/type&gt;
  &lt;overrides&gt;
    &lt;parameter&gt;annotator1/param1&lt;/parameter&gt;
    &lt;parameter&gt;annotator2/param2&lt;/parameter&gt;
  &lt;/overrides&gt;
&lt;/configurationParameter&gt;</programlisting>

<para>The value of the <literal>AggregateParam</literal> parameter
(whether assigned in the aggregate descriptor or at runtime by an application)
will override the value of parameter <literal>param1</literal> in <literal>annotator1</literal>
and also override the value of parameter <literal>param2</literal> in <literal>an</literal><literal>notator2</literal>.  No other
parameters will be affected.</para>

<para>For historical reasons only, if an aggregate Analysis
Engine descriptor declares a configuration parameter with no explicit
overrides, that parameter will override any parameters having the same name
within any delegate analysis engine.  This usage is strongly discouraged.  The UIMA SDK currently supports this usage but logs a warning message to
the log file.  This support may be
dropped in future versions.</para>

<h4><a id="_crossRef144">External
Resource Bindings</a></h4>

<para>Aggregate analysis engine descriptors can declare resource
bindings that bind resources to dependencies declared in any of the delegate
analysis engines (or their subcomponents, recursively) within that
aggregate.  This allows resource
sharing.  Any binding at this level
overrides (supersedes) any binding specified by a contained component or their
subcomponents, recursively.</para>

<para>For example, consider an aggregate Analysis Engine
Descriptor that contains delegate Analysis Engines with keys <literal>annotator1</literal>
and <literal>annotator2</literal>
(as declared in the <literal>&lt;delegateAnalysisEngine&gt;</literal> element &ndash; see <b><a class="crossrefText" href="Component_Descriptor_Reference.htm#_crossRef139">Delegate Analysis
Engine Specifiers</a></b>), where <literal>annotator1</literal> declares a
resource dependency with key <literal>myResource</literal> and <literal>annotator2</literal> declares a
resource dependency with key <literal>someResource</literal>.</para>

<para>Within that aggregate Analysis Engine Descriptor, the
following <literal>resourceManagerConfiguration</literal>
would bind both of those dependencies to a single external resource file.</para>

<programlisting>&lt;resourceManagerConfiguration&gt;</programlisting>

<programlisting>  &lt;externalResources&gt;
    &lt;externalResource&gt;
      &lt;name&gt;ExampleResource&lt;/name&gt;
      &lt;fileResourceSpecifier&gt;
        &lt;fileUrl&gt;file:MyResourceFile.dat&lt;/fileUrl&gt;
      &lt;/fileResourceSpecifier&gt;
    &lt;/externalResource&gt;
  &lt;/externalResources&gt;  </programlisting>

<programlisting>  &lt;externalResourceBindings&gt;
    &lt;externalResourceBinding&gt;
      &lt;key&gt;annotator1/myResource&lt;/key&gt;
      &lt;resourceName&gt;ExampleResource&lt;/resourceName&gt;
    &lt;/externalResourceBinding&gt;
    &lt;externalResourceBinding&gt;
      &lt;key&gt;annotator2/someResource&lt;/key&gt;
      &lt;resourceName&gt;ExampleResource&lt;/resourceName&gt;
    &lt;/externalResourceBinding&gt;
  &lt;/externalResourceBindings&gt;</programlisting>

<programlisting>&lt;/resourceManagerConfiguration&gt;</programlisting>

<para>The syntax for the <literal>externalResources</literal>
declaration is exactly the same as described previously.  In the resource bindings note the use of the
compound keys, e.g. <literal>annotator1/myResource</literal>.  This identifies the resource dependency key <literal>myResource</literal> within the
annotator with key <literal>annotator1</literal>.  Compound resource dependencies can be multiple levels deep to handle
nested aggregate analysis engines.</para>

<h4>Sofa Mappings</h4>

<para>Sofa mappings are specified between Sofa names declared in
this aggregate descriptor as part of the <literal>&lt;capability&gt;</literal>
section, and the Sofa names declared in the delegate components.  For purposes of the mapping, all the
declarations of Sofas in any of the capability sets contained within the <literal>&lt;capabilities&gt; </literal>element are considered together.</para>

<programlisting>&lt;sofaMappings&gt;
  &lt;sofaMapping&gt;
    &lt;componentKey&gt;[keyName]&lt;/componentKey&gt;
    &lt;componentSofaName&gt;[sofaName]&lt;/componentSofaName&gt;
    &lt;aggregateSofaName&gt;[sofaName]&lt;/aggregateSofaName&gt;
  &lt;/sofaMapping&gt;
  ...
&lt;/sofaMappings&gt;</programlisting>

<para>The &lt;componentSofaName&gt; may be omitted in the case
where the component is not aware of Multiple Views or Sofas.  In this case, the UIMA framework will arrange
for the specified &lt;aggregateSofaName&gt; to be the one visible to the
delegate component.</para>

<para>The &lt;componentKey&gt; is the key name for the component
as specified in the list of delegate components for this aggregate.</para>

<para>The sofaNames used must be declared as input or output
sofas in some capability set.</para>




  </subsection>
<subsection name="Flow Controller Descriptors"><a id="_crossRef145"> </a>



<para>The basic structure of a Flow Controller Descriptor is as
follows:</para>

<programlisting>&lt;?xml version=<quote>1.0</quote> encoding=<quote>UTF-8</quote> ?&gt; </programlisting>

<programlisting>&lt;flowControllerDescription 
    xmlns=<quote>http://uima.apache.org/resourceSpecifier</quote>&gt;</programlisting>

<programlisting>  &lt;frameworkImplementation&gt;org.apache.uima.java&lt;/frameworkImplementation&gt; </programlisting>

<programlisting>  &lt;implementationName&gt;[ClassName]&lt;/implementationName&gt; </programlisting>

<programlisting>  &lt;processingResourceMetaData&gt;
    ...
  &lt;/processingResourceMetaData&gt;</programlisting>

<programlisting>  &lt;externalResourceDependencies&gt;
    ...
  &lt;/externalResourceDependencies&gt;</programlisting>

<programlisting>  &lt;resourceManagerConfiguration&gt;
    ...
  &lt;/resourceManagerConfiguration&gt;</programlisting>

<programlisting>&lt;/flowControllerDescription&gt;</programlisting>

<para>The <literal>frameworkImplementation</literal> element must always be set to the
value <literal>org.apache.uima.java</literal>.</para>

<para>The <literal>implementationName</literal> element must contain the
fully-qualified class name of the Flow Controller implementation.  This must name a class that implements the <literal>FlowController</literal>
interface.</para>

<para>The <literal>processingResourceMetaData</literal> element contains essentially
the same information as a Primitive Analysis Engine Descriptor&apos;s <literal>analysisEngineMetaData</literal>
element, described in <emphasis>Section </emphasis><emphasis>23-297</emphasis><emphasis> <b><a class="crossrefText" href="Component_Descriptor_Reference.htm#_crossRef128">Analysis Engine Metadata</a></b></emphasis>.</para>

<para>The <literal>externalResourceDependencies</literal> and <literal>resourceManagerConfiguration</literal>
elements are exactly the same as in Primitive Analysis Engine Descriptors (see <emphasis>23-309</emphasis><emphasis> <b><a class="crossrefText" href="Component_Descriptor_Reference.htm#_crossRef135">External
Resource Dependencies</a></b></emphasis> and <emphasis>23-309</emphasis><emphasis> <b><a class="crossrefText" href="Component_Descriptor_Reference.htm#_crossRef136">Resource
Manager Configuration</a></b></emphasis>).</para>






  </subsection>
<subsection name="Collection Processing Component Descriptors"><a id="_crossRef146"> </a>



<para>There are three
types of Collection Processing Components &ndash; Collection Readers, CAS
Initializers, and CAS Consumers.  Each
type of component has a corresponding descriptor.  The structure of these descriptors is very
similar to that of primitive Analysis Engine Descriptors.</para>

<h3><a id="_crossRef147">Collection Reader Descriptors</a></h3>

<para>The basic
structure of a Collection Reader descriptor is as follows:</para>

<programlisting>&lt;?xml version=<quote>1.0</quote> encoding=<quote>UTF-8</quote> ?&gt; </programlisting>

<programlisting>&lt;collectionReaderDescription
    xmlns=<quote>http://uima.apache.org/resourceSpecifier</quote>&gt;</programlisting>

<programlisting>  &lt;frameworkImplementation&gt;org.apache.uima.java&lt;/frameworkImplementation&gt;
  &lt;implementationName&gt;[ClassName]&lt;/implementationName&gt; </programlisting>

<programlisting>  &lt;processingResourceMetaData&gt;
    ...
  &lt;/processingResourceMetaData&gt;</programlisting>

<programlisting>  &lt;externalResourceDependencies&gt;
   ...
  &lt;/externalResourceDependencies&gt;</programlisting>

<programlisting>  &lt;resourceManagerConfiguration&gt;</programlisting>

<programlisting>   ...</programlisting>

<programlisting>  &lt;/resourceManagerConfiguration&gt;</programlisting>

<programlisting>&lt;/collectionReaderDescription&gt;</programlisting>

<para>The <literal>frameworkImplementation</literal> element must always be set to the
value <literal>org.apache.uima.java</literal>.</para>

<para>The <literal>implementationName</literal> element contains the fully-qualified
class name of the Collection Reader implementation.  This must name a class that implements the <literal>CollectionReader</literal> interface.</para>

<para>The <literal>processingResourceMetaData</literal> element contains essentially
the same information as a Primitive Analysis Engine Descriptor&apos;s&apos; <literal>analysisEngineMetaData</literal> element:</para>

<programlisting>&lt;processingResourceMetaData&gt;</programlisting>

<programlisting>  &lt;name&gt; [String] &lt;/name&gt;
  &lt;description&gt;[String]&lt;/description&gt;
  &lt;version&gt;[String]&lt;/version&gt;
  &lt;vendor&gt;[String]&lt;/vendor&gt;</programlisting>

<programlisting>  &lt;configurationParameters&gt;
     ...
  &lt;/configurationParameters&gt;</programlisting>

<programlisting>  &lt;configurationParameterSettings&gt;
    ...
  &lt;/configurationParameterSettings&gt; </programlisting>

<programlisting>  &lt;typeSystemDescription&gt;
   ...
  &lt;/typeSystemDescription&gt; </programlisting>

<programlisting>  &lt;typePriorities&gt;
   ...
  &lt;/typePriorities&gt; </programlisting>

<programlisting>  &lt;fsIndexes&gt;
   ...
  &lt;/fsIndexes&gt;</programlisting>

<programlisting>  &lt;capabilities&gt;
   ...
  &lt;/capabilities&gt; </programlisting>

<programlisting>&lt;/processingResourceMetaData&gt;</programlisting>

<para>The contents of
these elements are the same as that described in <emphasis>23-297</emphasis><emphasis> <b><a class="crossrefText" href="Component_Descriptor_Reference.htm#_crossRef128">Analysis Engine Metadata</a></b></emphasis>, with the exception that the
capabilities section should not declare any inputs (because the Collection
Reader is always the first component to receive the CAS).</para>

<para>The <literal>externalResourceDependencies</literal> and <literal>resourceManagerConfiguration</literal> elements are exactly the
same as in the Primitive Analysis Engine Descriptors (see <emphasis>23-309</emphasis><emphasis> <b><a class="crossrefText" href="Component_Descriptor_Reference.htm#_crossRef135">External Resource
Dependencies</a></b></emphasis> and <emphasis>23-309</emphasis><emphasis> <b><a class="crossrefText" href="Component_Descriptor_Reference.htm#_crossRef136">Resource Manager
Configuration</a></b></emphasis>).</para>

<h3><a id="_crossRef148">CAS Initializer Descriptors</a></h3>

<para>The basic
structure of a CAS Initializer Descriptor is as follows:</para>

<programlisting>&lt;?xml version=<quote>1.0</quote> encoding=<quote>UTF-8</quote> ?&gt; </programlisting>

<programlisting>&lt;casInitializerDescription
    xmlns=<quote>http://uima.apache.org/resourceSpecifier</quote>&gt;</programlisting>

<programlisting>  &lt;frameworkImplementation&gt;org.apache.uima.java&lt;/frameworkImplementation&gt;
  &lt;implementationName&gt;[ClassName] &lt;/implementationName&gt;</programlisting>

<programlisting>  &lt;processingResourceMetaData&gt;
    ...
  &lt;/processingResourceMetaData&gt;</programlisting>

<programlisting>  &lt;externalResourceDependencies&gt;
    ...
  &lt;/externalResourceDependencies&gt;</programlisting>

<programlisting>  &lt;resourceManagerConfiguration&gt;
    ...
  &lt;/resourceManagerConfiguration&gt;</programlisting>

<programlisting>&lt;/casInitializerDescription&gt;</programlisting>

<para>The <literal>frameworkImplem</literal><literal>entation</literal>
element must always be set to the value <literal>org.apache.uima.java</literal>.</para>

<para>The <literal>implementationName</literal> element contains the fully-qualified
class name of the CAS Initializer implementation.  This must name a class that implements the <literal>CasInitializer</literal> interface.</para>

<para>The <literal>proc</literal><literal>essingResourceMetaData</literal>
element contains essentially the same information as a Primitive Analysis
Engine Descriptor&apos;s&apos; <literal>analysisEngineMetaData</literal>
element, as described in <emphasis>Section </emphasis><emphasis>23-297</emphasis><emphasis> <b><a class="crossrefText" href="Component_Descriptor_Reference.htm#_crossRef128">Analysis Engine Metadata</a></b></emphasis>, with the exception of some changes to
the capabilities section.  A CAS
Initializer&apos;s capabilities element looks like this:</para>

<programlisting>&lt;capabilities&gt;</programlisting>

<programlisting>  &lt;capability&gt;
    &lt;outputs&gt;
      &lt;type allAnnotatorFeatures=<quote>true|false</quote>&gt;[String]&lt;/type&gt;
      &lt;type&gt;[TypeName]&lt;/type&gt;
      ...
      &lt;feature&gt;[TypeName]:[Name]&lt;/feature&gt;
      ...
    &lt;/outputs&gt;</programlisting>

<programlisting>    &lt;outputSofas&gt;
      &lt;sofaName&gt;[name]&lt;/sofaName&gt;
      ...
    &lt;/outputSofas&gt;</programlisting>

<programlisting>    &lt;mimeTypesSupported&gt;
      &lt;mimeType&gt;[MIME Type]&lt;/mimeType&gt;
      ...
    &lt;/mimeTypesSupported&gt;
  &lt;/capability&gt;</programlisting>

<programlisting>  &lt;capability&gt;
    ...
  &lt;/capability&gt;</programlisting>

<programlisting>  ...</programlisting>

<programlisting>&lt;/capabilities&gt;</programlisting>

<para>The differences
between a CAS Initializer&apos;s capabilities declaration and a TAE&apos;s capabilities
declaration are that the CAS Initializer does not declare any input CAS types
and features or input Sofas (because it is always the first to operate on a
CAS), it doesn&apos;t have a language specifier,  and that the CAS Initializer may declare a set
of MIME types that it supports for its input documents.  Examples include: text/plain, text/html, and
application/pdf.  For a list of MIME
types see <a href="http://www.iana.org/assignments/media-types/">http://www.iana.org/assignments/media-types/</a>.  This information is currently only for users&apos;
information, the framework does not use it for anything.  This may change in future versions.</para>

<para>The <literal>externalResourceDependencies</literal> and <literal>resourceManagerConfiguration</literal> elements are exactly the
same as in the Primitive Analysis Engine Descriptors (see <emphasis>23-309</emphasis><emphasis> <b><a class="crossrefText" href="Component_Descriptor_Reference.htm#_crossRef135">External Resource
Dependencies</a></b></emphasis> and <emphasis>23-309</emphasis><emphasis> <b><a class="crossrefText" href="Component_Descriptor_Reference.htm#_crossRef136">Resource Manager
Configuration</a></b></emphasis>).</para>

<h3><a id="_crossRef149">CAS Consumer Descriptors</a></h3>

<para>The basic
structure of a CAS Consumer Descriptor is as follows:</para>

<programlisting>&lt;?xml version=<quote>1.0</quote> encoding=<quote>UTF-8</quote> ?&gt; </programlisting>

<programlisting>&lt;casConsumerDescription 
    xmlns=<quote>http://uima.apache.org/resourceSpecifier</quote>&gt;</programlisting>

<programlisting>  &lt;frameworkImplementation&gt;org.apache.uima.java&lt;/frameworkImplementation&gt; </programlisting>

<programlisting>  &lt;implementationName&gt;[ClassName] &lt;/implementationName&gt; </programlisting>

<programlisting>  &lt;processingResourceMetaData&gt;
    ...
  &lt;/processingResourceMetaData&gt;</programlisting>

<programlisting>  &lt;externalResourceDependencies&gt;
    ...
  &lt;/externalResourceDependencies&gt;</programlisting>

<programlisting>  &lt;resourceManagerConfiguration&gt;
    ...
  &lt;/resourceManagerConfiguration&gt;</programlisting>

<programlisting>&lt;/casConsumerDescription&gt;</programlisting>

<para>The <literal>frameworkImplementation</literal> element must always be set to the
value <literal>org.apache.uima.java</literal>.</para>

<para>The <literal>implementationName</literal> element must contain the
fully-qualified class name of the CAS Consumer implementation.  This must name a class that implements the <literal>CasC</literal><literal>onsumer</literal>
interface.</para>

<para><a id="_crossRef150">The </a><literal>processingResourceMetaData</literal> element contains essentially
the same information as a Primitive Analysis Engine Descriptor&apos;s <literal>analysisEngineMetaData</literal>
element, described in <emphasis>Section </emphasis><emphasis>23-297</emphasis><emphasis> <b><a class="crossrefText" href="Component_Descriptor_Reference.htm#_crossRef128">Analysis Engine Metadata</a></b></emphasis>, except that the CAS Consumer
Descriptor&apos;s <literal>capab</literal><literal>ilities</literal>
element should not declare outputs or outputSofas (since CAS Consumers do not
modify the CAS).</para>

<para>The <literal>externalResourceDependencies</literal>
and <literal>resourceManagerConfiguration</literal> elements are exactly the
same as in Primitive Analysis Engine Descriptors (see <emphasis>23-309</emphasis><emphasis> <b><a class="crossrefText" href="Component_Descriptor_Reference.htm#_crossRef135">External
Resource Dependencies</a></b></emphasis> and <emphasis>23-309</emphasis><emphasis> <b><a class="crossrefText" href="Component_Descriptor_Reference.htm#_crossRef136">Resource
Manager Configuration</a></b></emphasis>).</para>






  </subsection>
<subsection name="Service Client Descriptors"><a id="_crossRef151"> </a>



<para>Service Client Descriptors specify only a location of a
remote service.  They are therefore much
simpler in structure.  In the UIMA SDK, a
Service Client Descriptor that refers to a valid Analysis Engine or CAS
Consumer service can be used in place of the actual Analysis Engine or CAS
Consumer Descriptor.  The UIMA SDK will
handle the details of calling the remote service.  (For details on <emphasis>deploying</emphasis> an Analysis
Engine or CAS Consumer as a service, see <a class="crossrefText" href="CPE_Descriptor_Reference.htm#_crossRef160">Chapter
24, <b>Collection Processing Engine Descriptor Reference</b></a>).</para>

<para>The UIMA SDK is extensible to support different types of
remote services.  In future versions,
there may be different variations of service client descriptors that cater to
different types of services.  For now,
the only type of service client descriptor is the <literal>uriSpecifier</literal>, which supports
the SOAP and Vinci protocols.</para>

<programlisting>&lt;?xml version=<quote>1.0</quote> encoding=<quote>UTF-8</quote> ?&gt;
&lt;uriSpecifier xmlns=<quote>http://uima.apache.org/resourceSpecifier</quote>&gt;
  &lt;resourceType&gt;AnalysisEngine | CasConsumer &lt;/resourceType&gt;
  &lt;uri&gt;[URI]&lt;/uri&gt; 
  &lt;protocol&gt;SOAP | SOAPwithAttachments | Vinci&lt;/protocol&gt; 
  &lt;timeout&gt;[Integer]&lt;/timeout&gt;
  &lt;parameters&gt;
    &lt;parameter name=<quote>VNS_HOST</quote> value=<quote>some.internet.ip.name-or-address</quote>/&gt;
    &lt;parameter name=<quote>VNS_PORT</quote> value=<quote>9000</quote>/&gt;
  &lt;/parameters&gt; 
&lt;/uriSpecifier&gt;</programlisting>

<para>The <literal>resourceType</literal> element is required for new descriptors, but
is currently allowed to be omitted for backward compatibility.  It specifies the type of component (Analysis
Engine or CAS Consumer) that is implemented by the service endpoint described
by this descriptor.</para>

<para>The <literal>uri</literal> element contains the URI for the web service.  (Note that in the case of Vinci, this will be
the service name, which is looked up in the Vinci Naming Service.)</para>

<para>The <literal>protocol</literal> element may be set to SOAP, SOAPwithAttachments,
or Vinci; other protocols may be added later.  These specify the particular data transport format that will be used.</para>

<para>The <literal>t</literal><literal>imeout</literal> element is optional.  If present, it specifies the number of
milliseconds to wait for a request to be processed before an exception is
thrown.  A value of zero or less will
wait forever.  If no timeout is
specified, a default value (currently 60 seconds) will be used.</para>

<para>The parameter element is optional.  If present, it specifies the Vinci naming
service host and/or port number.  If not
present, the value used for these comes from parameters passed on the Java
command line using the <literal>-DVNS_HOST=&lt;host&gt; </literal>and/or <br/>
<literal>-DVNS_PORT=&lt;port&gt;</literal> system arguments.  If not present, and a system argument is also
not present, the values for these default to <literal>localhost</literal> for the <literal>VNS_HOST</literal> and <literal>9000</literal> for the <literal>VNS_PORT</literal>.</para>

<para>For details on how to deploy and call Analysis Engine and
CAS Consumer services, see <emphasis>Section </emphasis><a class="crossrefText" href="Application_Developers_Guide.htm#_crossRef64"><b>6.6 </b>, <b>Working with Analysis Engine and CAS Consumer
Services</b></a>.</para>

</chapter>